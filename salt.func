##########################################################################
## @file			salt.func
## @brief			The heart of SALT - all global functions
## @author			steadfasterX <steadfasterX -AT- gmail -DOT- com>
## @date                        2017-2018
## @copyright			LGPL v3
## @details                     SALT - [S]teadfasterX [A]ll-in-one [L]G [T]ool
##
## global functions for SALT
##
## include this with:
## source salt.func
#
##########################################################################
# doxygen copy templates:
#
# # @var 
# # @brief 
# # @showinitializer
# # @details 
#
# # @fn F_NAME()
# # @brief ..
# # @param 1 ..
# # @return ..
# # @exception ..
# # @details ..
#
##########################################################################
VARS="${0%/*}/salt.vars"
export HASHES="${0%/*}/salt.hashes"

source "$VARS"
[ $? -ne 0 ]&& echo "ERROR: including $VARS" && exit 3

source "$HASHES"
[ $? -ne 0 ]&& echo "ERROR: including $HASHES" && exit 3

# set CR arg
case $CRMODE in
    yes) export CROPT="--cr yes";;
    no) export CROPT="--cr no";;
    *) export CROPT="";;
esac
  
######################################################################################

# there is no need to change these as they get auto set by the VERSION var
if [ "${VERSION/*:}" == "TESTING" ];then
    export BRSALT=develop
    export BRKDZ=develop
    export BRLAF=g4-develop
    export BROSALT=master
    export BROKDZ=master
    export BROLAF=g4-stable
    export VCHK=https://raw.githubusercontent.com/steadfasterX/SALT/develop/salt.vars
else
    export BRSALT=master
    export BRKDZ=master
    export BRLAF=g4-stable
    export BROSALT=develop
    export BROKDZ=develop
    export BROLAF=g4-develop
    export VCHK=https://raw.githubusercontent.com/steadfasterX/SALT/master/salt.vars
fi

######################################################################################

# do not echo but write log entry
F_LOG(){
    # takes 1 argument
    # 1 => Message to log/echo (can handle \t and \n)
  
    echo -e "$(date '+%F %T'): $1" >> $LOG
}; export -f F_LOG

# echo output and save it in a log as well
F_ELOG(){
  # takes 1 argument
  # 1 => Message to log/echo (can handle \t and \n)
  
  echo -e "$(date '+%F %T'): $1" | tee -a $LOG

}; export -f F_ELOG
######################################################################################
F_LOG "CR setting: $CRMODE = $CROPT"
######################################################################################

# print a message
F_MSG(){ F_LOG "$FUNCNAME: started"
    # takes 2 arguments
    #   
    #  1 => box width
    #  2 => message to show
    # optional:
    #  3 => free args
    $FYAD --width=$1 --title="$YTITLE" --text "$2" $3
    RET=$?
    F_LOG "$2"
    F_LOG "$FUNCNAME: ended"
    echo $RET
}; export -f F_MSG

# print an error message
F_MSGE(){ F_LOG "$FUNCNAME: started"
    # takes up to 3 arguments
    #
    # 1 => width
    # 2 => message
    #
    # optional:
    # 3 => yad stuff
    
    $FYAD --width="$1" --title="$YTITLE - ERROR" --image="$SICONS/error.png" --text "ERROR:\n\n$2" $3 --button=Exit:0
    RES=$?
    F_LOG "ERROR: $2"
    F_LOG $RES
    echo $RES
}; export -f F_MSGE

# print an OK message
F_MSGOK(){ F_LOG "$FUNCNAME: started"
    # takes up to 3 arguments
    #
    # 1 => width
    # 2 => message
    #
    # optional:
    # 3 => yad stuff

    $FYAD --width="$1" --title="$YTITLE - SUCCESS" --image="$SICONS/ok_64x64.png" --text "\n$2" $3 --button=Close:0
    RES=$?
    F_LOG "$2"
    F_LOG $RES
    echo $RES
}; export -f F_MSGOK

# print a warning message
F_MSGW(){ F_LOG "$FUNCNAME: started"
    # takes up to 3 arguments
    #
    # 1 => width
    # 2 => message
    #
    # optional:
    # 3 => yad stuff

    $FYAD --width="$1" --title="$YTITLE - SUCCESS" --image="$SICONS/warning_64x64.png" --text "\n$2" $3 --button=Close:0
    RES=$?
    F_LOG "$2"
    F_LOG $RES
    echo $RES
}; export -f F_MSGW

# check errorcode + exit when not errorcode not as expected
F_ERR(){ F_LOG "$FUNCNAME: started"
  # takes 2-4 arguments
  #
  # mandantory:
  #   1 => the process initiating this function
  #   2 => the errorcode (usually $? in your call)
  # optional (4 requires at least an empty 3):
  #   3 => the message to show
  #   4 => the expected error code (if missing we expect 0)
  CALLER=$1
  ERRCODE=$2
  MSG="$3"
  EXPECTED=$4

  [ -z "$EXPECTED" ] && EXPECTED=0
  
  if [ -z "$CALLER" ]||[ -z "$ERRCODE" ];then
    F_ELOG "Required argument missing in $FUNCNAME!"
    F_EXIT $FUNCNAME 3
  fi
  if [ "$ERRCODE" != "$EXPECTED" ];then
    F_ELOG "ERROR: $ERRCODE occurred in $CALLER (expected $EXPECTED, got $ERRCODE)"
    [ ! -z "$MSG" ] && F_MSGE 400 "$MSG"
    F_EXIT "${CALLER}->${FUNCNAME}" 4
  else
    echo "OK: $CALLER"
  fi
}; export -f F_ERR

# exit properly
F_EXIT(){ F_LOG "$FUNCNAME: started"
  # takes 3 arguments
  # mandantory:
  #   1 => the function or reason who calls the exit function
  #   2 => the exitcode to be used
  #
  # optional:
  #   3 => type: cleaning lock file (full) or just close (when not set)
  EREASON=$1
  ECODE=$2
  ETYPE=$3
  
  F_ELOG "EXIT: $EREASON with code $ECODE"
  
  [ "$ETYPE" == "full" ] && rm -vf $LOCKFILE >> $LOG

  exit $ECODE
  F_LOG "$FUNCNAME: ended"
}; export -f F_EXIT

# get current phone data
F_GETINFO(){ F_LOG "$FUNCNAME: started"
    # takes no arguments

    $FYAD --title="$YTITLE - COLLECTING" --text "\n  Collecting device information..." --width=400 --timeout=25 --timeout-indicator=right --no-buttons &
    PBPP=$!
 
    IARB=$(F_CDARB)
    F_LOG "$FUNCNAME: ARB $IARB"
    USU=$(F_CKUSU)
    F_LOG "$FUNCNAME: USU $USU"
    ROMCOMP=$(F_ROMCOMP)
    F_LOG "$FUNCNAME: ROMCOMP $ROMCOMP"
    LAFVER=$(F_CHKLAFV)
    F_LOG "$FUNCNAME: LAFVER $LAFVER"

    echo "usu:${USU}" \
      && echo "romcomp:$ROMCOMP" \
      && echo "arb:${IARB}" \
      && echo "lafver:$LAFVER" \
      && $PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!INFO GPRO \x08\x0b\0\0' --rawshell \
       | $PYTHONBIN $LAFPATH/scripts/parse-props.py - \
       | egrep "(device_sw_version|model_name|secure_device|laf_sw_version|device_factory_version|target_country|battery_level|imei|target_operator|serial)" | tr "\n" " " | tr -d "'" 
    F_LOG "$FUNCNAME: $(kill $PBPP)"
    F_LOG "$FUNCNAME: ended"
}; export -f F_GETINFO

# checks which ROM type is compatible with UsU on that device 
F_ROMCOMP(){ F_LOG "$FUNCNAME: started"
    # takes no arg

    DEVTMO=$($PYTHONBIN $LAFPATH/partitions.py ${CROPT} --list 2>&1 | grep -c carrier | tee -a $LOG)
    DEVEUR=$($PYTHONBIN $LAFPATH/partitions.py ${CROPT} --list 2>&1 | grep -c cust | tee -a $LOG)
    F_LOG "UsU compatibility: $DEVTMO (0=h815, 1=h811)"
    if [ "$DEVTMO" == "1" ];then
        echo "H811"
    elif [ "$DEVEUR" == "1" ];then
        echo "H815"
    else
        echo "unknown"
        F_LOG "UsU compatibility: cannot be detected! full GPT:"
        $PYTHONBIN $LAFPATH/partitions.py ${CROPT} --list 2>&1 >> $LOG
    fi
}; export -f F_ROMCOMP

# check the ARB of a KDZ file
F_KDZARB(){  F_LOG "$FUNCNAME: started with $@"
    # takes 2 args, returns ARB value found
    #
    # 1 => full path to kdz file
    # 2 => full extract path

    LGKDZ="$1"
    LGTARGET="$2"

    [ -z "$LGKDZ" -o ! -f "$LGKDZ" ] && F_ERR $FUNCNAME 3 "Internal error: empty LGKDZ or file not found"
    [ -z "$LGTARGET" -o ! -d "$LGTARGET" ] && F_ERR $FUNCNAME 3 "Internal error: empty LGTARGET or directory not found"

 
    F_LOG "$FUNCNAME: cleanup.."
    find "$LGTARGET" -type f -maxdepth 1 -name 'sbl*' -or -name 'xbl*' -exec rm -vf {}\\; >> $LOG 2>&1
    IRES=$($KDZMGR --batch --list -x "$LGKDZ" -d "$LGTARGET" 2>&1)
    ARBSLICE=$(echo "$IRES" |egrep "sbl|xbl"|head -n1|cut -d ":" -f 1)
    if [ -z "$ARBSLICE" ];then
        F_LOG "$FUNCNAME: no ARB or slice found >$ARBSLICE< .. skipping ARB detection .."
        echo "arb-detect-error"
    else
        F_LOG "$FUNCNAME: found ARB in slice >$ARBSLICE< .. extracting.."
        # extract ARB slice
        $KDZMGR --batch -x "$LGKDZ" -d "$LGTARGET" --slice "$ARBSLICE" >> $LOG 2>&1
        ARBFILE=$(find "${LGTARGET}/extracteddz" -type f -maxdepth 1 -name 'sbl*' -or -name 'xbl*')
        F_LOG "$FUNCNAME: ARBFILE = $ARBFILE"
        # get and print the ARB
        F_CKARB "$ARBFILE"
    fi
}; export -f F_KDZARB

# extract a KDZ
F_EXTRACTKDZ(){ F_LOG "$FUNCNAME: started with $@"
    # takes 2-3 arguments
    #
    # required:
    #   1 => KDZ file name (full path)
    #   2 => Target directory
    # optional:
    #   3 => auto mode (e.g. for KDZ flashing)

    LGKDZ="$1"
    LGTARGET="$2"
    AUTOM="$3"

    [ -z "$LGKDZ" -o ! -f "$LGKDZ" ] && F_ERR $FUNCNAME 3 "Internal error: empty LGKDZ or file not found"
    [ -z "$LGTARGET" -o ! -d "$LGTARGET" ] && F_ERR $FUNCNAME 3 "Internal error: empty LGTARGET or directory not found"

    # ensure the target dir does not contain old image files
    [ "${LGTARGET}/extracteddz" ] && rm -rf "${LGTARGET}/extracteddz"
    [ "${LGTARGET}/extractekdz" ] && rm -rf "${LGTARGET}/extractedkdz"

    # open yad listener
    echo 0> /tmp/${FUNCNAME}_l
    tail -f /tmp/${FUNCNAME}_l | $FYAD --title="$YTITLE - COLLECT" --text="\n" --progress-text="Collecting KDZ information ..." --width=400 --progress --pulsate --no-buttons &
    echo 1 >> /tmp/${FUNCNAME}_l
    tail_pid=$!

    # grab the partition list
    IRES=$($KDZMGR --batch --list -x "$LGKDZ" -d "$LGTARGET" 2>&1)
    IRESDATA=$(echo -e "$IRES" |grep ":data" | sort -t : -k 2)
    IRESEMPTY=$(echo -e "$IRES" |grep ":empty" | sort -t : -k 2)

    # grab the ARB of the KDZ
    KDZARB=$(F_KDZARB "$LGKDZ" "$LGTARGET")

    # close yad listener
    kill $tail_pid
    rm /tmp/${FUNCNAME}_l

    # build the extract list based on the UsU state
    case "$LGUSU" in
        yes) IRESAUTO=$(echo -e "$IRESDATA" | egrep -iv "($AUTONOEXTRACTUSU)")
        ;;
        no|no_device_found) IRESAUTO=$(echo -e "$IRESDATA" | egrep -iv "($AUTONOEXTRACT)")
        ;;
        *) kill $tail_pid
           rm /tmp/${FUNCNAME}_l
           F_MSGE 500 "Unexpected LGUSU result ($LGUSU).. "
           F_EXIT "$FUNCNAME: Cannot determine UsU state" 3 
        ;; 
    esac
    F_LOG "collected data:\nUsU: $LGUSU\nIRESDATA:\n$IRESDATA\nIRESEMPTY:\n$IRESEMPTY\nIRESAUTO:\n$IRESAUTO"
    F_LOG "$FUNCNAME: $(kill $PBPP)"

    if [ x"$AUTOM" == "xauto" ];then
        CHOOSENP=$(echo -e "$IRESAUTO"| cut -d ":" -f 1-2)
    else
        IRESSORTED=$(echo -e "$IRESDATA\n$IRESEMPTY")
        BTNRET=66
        while [ "$BTNRET" -eq 77 -o "$BTNRET" -eq 66 ];do
            if [ "$BTNRET" == 66 ];then
              FCHOOSENP=$(for slice in $IRESSORTED;do if [ "${slice/*:/}" == "data" ];then echo -e "true:$slice"; else echo -e "false:$slice";fi | tr ':' '\n' ;done \
                        | $FYAD --height=800 --width=1000 --title="$YTITLE - EXTRACT" \
                        --text "\n  This KDZ has an <a href='https://bit.do/antirollg4'>ARB</a> of:  <span color='#ff0000' size='large'><b>$KDZARB</b></span>\n\n  Select partition(s) to EXTRACT:\n"\
                        --list --checklist \
                        --column="Selection":CHK \
                        --column="#" \
                        --column="Partition":TXT \
                        --column="Type" \
                        --listen --no-selection \
                        --button="Deselect All":77 \
                        --button=Extract:0 \
                        --button=Abort:3)
              BTNRET="${PIPESTATUS[0]}"
              CHOOSENP=$(echo "$FCHOOSENP" | cut -d "|" -f 2,3 | tr "|" ":"| tr "\n" " ")
              F_LOG "$FUNCNAME BTNRET: $BTNRET"
            else 
                if [ "$BTNRET" == 77 ];then
                  FCHOOSENP=$(for slice in $IRESSORTED;do if [ "${slice/*:/}" == "data" ];then echo -e "false:$slice"; else echo -e "false:$slice";fi | tr ':' '\n' ;done \
                            | $FYAD --height=800 --width=1000 --title="$YTITLE - EXTRACT" \
                            --text "\n  This KDZ has an <a href='https://bit.do/antirollg4'>ARB</a> of:  <span color='#ff0000' size='large'><b>$KDZARB</b></span>\n\n  Select partition(s) to EXTRACT:\n"\
                            --list --checklist \
                            --column="Selection":CHK \
                            --column="#" \
                            --column="Partition":TXT \
                            --column="Type" \
                            --listen --no-selection \
                            --button="Select All (with data)":66 \
                            --button=Extract:0 \
                            --button=Abort:3)
                  BTNRET="${PIPESTATUS[0]}"
                  CHOOSENP=$(echo "$FCHOOSENP" | cut -d "|" -f 2,3 | tr "|" ":"| tr "\n" " ")
                  F_LOG "$FUNCNAME BTNRET: $BTNRET"
                else
                  break
                fi
            fi
          done
    fi
    F_LOG "CHOOSENP: $CHOOSENP"

    CHCOUNT=$(echo "$CHOOSENP" |tr " " "\n" |grep -c :)
    [ $CHCOUNT -lt 1 ] && F_MSGE 700 "No partition selected or aborted by user" && F_EXIT $FUNCNAME $CHCOUNT

    F_ELOG "choosen partitions: $CHOOSENP -> $CHCOUNT"

    # open yad listener
    echo 0> /tmp/e
    tail -f /tmp/e | $FYAD --title="$YTITLE - EXTRACT" --text="\n  <b>SALT is now extracting ...</b>\n  (just wait until this dialog closes)\n" --width=900 --progress --button='Close (WAIT until FINISHED)':0 --auto-close &
    tail_pid=$!

    MGRARGS=
    for slice in $CHOOSENP;do
        CNT=$((CNT+1))
        slicename=${slice/*:/}
        slicenum=${slice/:*/}
        echo "#extracting ${slicename} ..." >>/tmp/e
        [ $CNT -ne $CHCOUNT ] && MGRARGS="-D"
        $KDZMGR --batch -x "$LGKDZ" -d "$LGTARGET" --slice $slicenum --with-cache --with-userdata $MGRARGS >> $LOG 2>&1

        CNTPERC=$(($CNT * 100 / $CHCOUNT))
        echo $CNTPERC >>/tmp/e
        [ $CNT -eq $CHCOUNT ] && echo '# FINISHED!' >>/tmp/e && F_LOG "$FUNCNAME: Extract finished"
    done
    EXERR=$?

    # cleanup dz (but leave the dlls)
    rm -fv "$LGTARGET/extractedkdz/*.dz" >> $LOG

    # ensure regular users can work with the extracted stuff
    if [ "$LGTARGET" != "/tmp" ] && [ "$LGTARGET" != "/" ];then
        chown -Rv ${REALUSER} "$LGTARGET" >> $LOG
    else
        chown -Rv ${REALUSER} "$LGTARGET/extractedkdz" "$LGTARGET/extracteddz" >> $LOG
    fi

    # close yad listener
    kill $tail_pid

    if [ $EXERR -ne 0 ];then 
        F_ERR $FUNCNAME $EXERR "ERROR occured or aborted by user!"
    else
        [ x"$AUTOM" != "xauto" ] && $FYAD --width="500" --title="$YTITLE - SUCCESS" --image="$SICONS/ok_64x64.png" --text "\nAll partitions extracted!\n" \
            --button='Open target folder':"sudo -u $REALUSER xdg-open '$LGTARGET/extracteddz'" \
            --button='Mount an image':"bash -c 'F_MOUNTPARTS $LGTARGET/extracteddz'" \
            --button=Close:0
    fi
    F_LOG "$FUNCNAME: ended"
}; export -f F_EXTRACTKDZ

# check device for for antirollback bullshit (I'm still pissed off how a vendor is doing this! I mean HARDBRICK a phone ?? wtf LG?)
F_CDARB(){ F_LOG "$FUNCNAME: started"
    # takes no arguments
    #
    DEVARBEMPTY=0
    DEVARB=$($PYTHONBIN $LAFPATH/partitions.py ${CROPT} --batch --dump - sbl1 2>> $LOG| strings | grep "0 SW_ID" |cut -d " " -f 2 | head -n 1 | sed -e 's/0\{16,16\}/zero/g' | tr -d "0")
    [ -z "$DEVARB" ] && DEVARB="0" && DEVARBEMPTY=1 && F_LOG "EMPTY ARB DETECTED:\n$($PYTHONBIN $LAFPATH/partitions.py ${CROPT} --batch --dump /tmp/sbl1.err sbl1 && strings /tmp/sbl1.err | grep -C 1 SW_ID 2>&1)" && F_LOG "Please send this log and the SBL1 dump in /tmp/sbl1.err" && F_LOG "$($PYTHONBIN $LAFPATH/partitions.py ${CROPT} --list --debug 2>&1)" && F_LOG "$(lsusb -v)"
    [ "$DEVARB" == "zero" ] && DEVARB=0 && F_LOG "ARB valid and 0"
    F_LOG "$FUNCNAME: DEVARB=$DEVARB, DEVARBEMPTY=$DEVARBEMPTY"
    echo "${DEVARB}:${DEVARBEMPTY}"
    F_LOG "$FUNCNAME: ended"
}; export -f F_CDARB

# dumps a single partition
F_DUMPPART(){ F_LOG "$FUNCNAME: started with $@"
    # takes 2 args
    #
    # 1 => partition name
    # 2 => path to store

    [ -z $1 -o -z $2 ] && F_EXIT "$FUNCNAME missing args!" 3

    PNAME=$1
    BPTH="$2"
    BFL="${BPTH}/${PNAME}"

    [ ! -d "$BPTH" ] && mkdir -p "$BPTH"
    $PYTHONBIN $LAFPATH/partitions.py ${CROPT} --batch --dump $BFL $PNAME

}; export -f F_DUMPPART

# check for the UsU Unlock (G4 only)
F_CKUSU(){ F_LOG "$FUNCNAME: started"
    # takes no arguments
    #
    (F_DUMPPART aboot /tmp/UsU/check 2>&1) >> $LOG
    REMAB=$(sha256sum /tmp/UsU/check/aboot | cut -d " " -f1)

    USUDET=0
    [ "$USUHASH" == "$REMAB" ] && USUDET=1
    F_LOG "$FUNCNAME: USU=$USUDET (1=yes, 0=no)"
    unset USUMNM
    [ $USUDET == 1 ] && USUMNM="$(F_USUMODEL)"
    echo "${USUDET}:${USUMNM}"
    F_LOG "$FUNCNAME: ended"
}; export -f F_CKUSU

# check for the real modelname when UsU
F_USUMODEL(){ F_LOG "$FUNCNAME: started"
    # takes no arguments
    #
    (F_DUMPPART raw_resources /tmp/UsU 2>&1) >> $LOG
    REMRR=$(dd if=/tmp/UsU/raw_resources skip=3145722 count=6 bs=1 2>>/dev/null | strings)
    F_LOG "$FUNCNAME: RR based USUMODEL=$REMRR"
    echo "${REMRR}"
    F_LOG "$FUNCNAME: ended"
}; export -f F_USUMODEL

# check local file for antirollback bullshit
# (I'm still pissed off that LG is REALLY doing this! I mean HARDBRICK a phone ?? wtf LG? Its MY decision if I wanna use an outdated/insecure ROM version!)
F_CKARB(){ F_LOG "$FUNCNAME: started"
    # takes 1 argument
    #  
    # 1 => full path to the file to check

    ARBFILE="$1"

    if [ ! -f "$ARBFILE" ];then
        F_MSGE 700 "Missing required file to check for ARB\n  (checked this filename: $ARBFILE)!"
        echo "arb-detect-error"
    else
        KDZARB=$(strings "$ARBFILE" | grep "0 SW_ID" |cut -d " " -f 2 |tr -d "0")
        [ -z "$KDZARB" ] && KDZARB=0
        F_LOG "KDZARB=$KDZARB"
        echo $KDZARB
    fi
    F_LOG "$FUNCNAME: ended"
}; export -f F_CKARB

# check device model
F_CHKMODEL(){ F_LOG "$FUNCNAME: started"
    # takes 1 argument
    #
    # 1 => KDZFILE to compare

    KFILE="$1"
    [ -z "$KFILE" -o ! -f "$KFILE" ] && F_ERR $FUNCNAME 3 "\n  ERROR!\n\n  KFILE missing for compare!"

    DEVINF=$(F_GETINFO)
    for i in $DEVINF;do
        case ${i/:*/} in
           model_name) LGMODEL=${i/*:/};;
        esac
    done
    KDZMODEL=$(dd if=$KFILE bs=512 count=10000 2>&1| strings | egrep -m1 'LG-[L|H|V]')
    if [ -z "$KDZMODEL" ] ;then
        RES="${LGMODEL}:unknown"
    else
        RES="${LGMODEL}:${KDZMODEL}"
    fi
    F_LOG "$FUNCNAME: $RES"
    echo $RES
    F_LOG "$FUNCNAME: ended"
} ; export -f F_CHKMODEL

# checks if UsU variable is readable and set correctly
F_USUVARVALID(){ F_LOG "$FUNCNAME: started"
    if [ "$LGUSU" == "yes" -o "$LGUSU" == "no" ];then echo 1; else echo 0; fi
 } ; export -f F_USUVARVALID

# flash a KDZ
F_FLASHKDZ(){ F_LOG "$FUNCNAME: started"
    # takes 5 arguments
    #
    #   1 => KDZ filename
    #   2 => Factory reset
    #   3 => Model check
    #   4 => ARB check
    #   5 => test mode

    LGKDZ="$1"
    LGFR="$2"
    LGCHKMOD="$3"
    LGARB="$4"
    LGDRY="$5"

    # autoextract kdz without userdata and cache
    KDZTMP=/tmp
    F_EXTRACTKDZ "$LGKDZ" "$KDZTMP" auto

    # test mode?
    if [ "$LGDRY" != "FALSE" ];then
        ($KDZMGR --batch --flash "$KDZTMP/extracteddz" --test 2>&1) | tee -a $LOG | $FYAD --title="$YTITLE - FLASH" --text-info --text "\n  <b><span color='#009900'>FLASHING KDZ (TEST)...</span></b>\n" --listen --tail --height=600 --width=900 --wrap --fore=blue --button="Next":0
        $FYAD --title="$YTITLE - FLASH" --text "\n  TEST run finished\n\n  Do you want to continue to FLASH in REAL now?" --button=FLASH:1 --button=Cancel:0
        [ $? -ne 1 ] && echo canceling.. && F_EXIT $FUNCNAME $?
    fi

    # check device connection
    F_CHKDEVCON

    # that one is required for flashing (the device must be connected and UsU state must be detected!)
    VARSET=$(F_USUVARVALID)
    if [ "$VARSET" -eq 0 ];then F_MSGE 500 "ERROR: Cannot determine UsU state?! aborted.."; F_EXIT "$FUNCNAME" 3; fi

    # recheck valid image files
    # TODO

    # check device model
    CHKMRES=$(F_CHKMODEL "$LGKDZ")
    
    # check ARB
    ARBOK=0
    KARB=$(F_CKARB "$KDZTMP/extracteddz/sbl1.image")
    DARB=$(F_CDARB)
    F_LOG "KARB: $KARB, DARB: $DARB"
    # verify the internal functions do not generate crap
    [ -z "$KARB" -o -z "$DARB" ] && F_ERR $FUNCNAME 3 "\n  ERROR!\n\n  Device ARB or KDZ ARB cannot be checked! ABORTED!!"
    # verify ARB
    [ "$KARB" -eq "${DARB/:*}" ] && ARBOK=1 && ARBINC=0 && F_LOG "ARB is equal between KDZ and device"
    [ "$KARB" -gt "${DARB/:*}" ] && ARBOK=1 && ARBINC=1 && F_MSGW 800 "ARB will be increased!\n\nThat means you can not rollback to previous versions once flashed!\n\nRead more about ARB here:\n\n<a href='https://bit.do/antirollg4'>ARB explained</a>"
    [ "$KARB" -lt "${DARB/:*}" ] && ARBOK=0 && ARBINC=0 && F_MSGE 800 "The ARB of the KDZ you trying to flash is lower then your device! ABORTED!\n\nRead more about ARB here:\n\n<a href='https://bit.do/antirollg4'>ARB explained</a>"
    # a bulletproof method to avoid issues with any of the above (e.g. when KARB or DARB are not digits etc)
    [ "$ARBOK" -ne 1 ] && F_MSGE 500 "Issues regarding determining ARB! ABORTED!" && F_EXIT "$FUNCNAME: ARB check failed" 4

    # manual ARB verification by the user
    if [ -z "${CHKMRES/*:}" ] || [ -z "${CHKMRES/:*}" ]|| [ "${CHKMRES/:*}" == "unknown" ] || [ "${CHKMRES/*:}" != "${CHKMRES/:*}" ];then
        FYAD --title="$YTITLE - CHECKUP" --image="$SICONS/salt_logo_128x128.png" --text "\n  WARNING: <b><span color='#ff0000'>KDZ file and device information does not match!</span></b>\n  Device model:\t${CHKMRES/*:}\n  KDZ is for:\t\t${CHKMRES/:*}\n\n  ARB of your device <b>seems</b> to be compatible with the KDZ file\n  Device:\t${DARB/:*}\n  KDZ:\t$KARB\n\n  You can doublecheck <a href='http://tinyurl.com/antirollg4'>here</a>\n\n  Do you really want to continue and so FLASH now?" --button="Flash (may HARD BRICK)":0 --button=Cancel:1
    else
        $FYAD --title="$YTITLE - CHECKUP" --image="$SICONS/salt_logo_128x128.png" --text "\n  KDZ <b>file and device</b> information match\n  Device model:\t${CHKMRES/*:}\n  KDZ is for:\t\t${CHKMRES/:*}\n\n  ARB of your device <b>seems</b> to be compatible with the KDZ file\n  Device:\t${DARB/:*}\n  KDZ:\t$KARB\n  You can doublecheck ARB <a href='http://tinyurl.com/antirollg4'>here</a>\n\n  Do you really want to continue and so FLASH now?" --button="Flash (on your own risk)":0 --button=Cancel:1
    fi
    # abort when needed
    [ $? -ne 0 ] && F_ERR $FUNCNAME 3 "\n  Aborted on user check verification"

    # If all the above is fine: FLASH
    F_FLASHPART "$KDZTMP/extracteddz" auto

    # factory reset to avoid bootloop (cache gets deleted by FLASHPART already)
    # TODO: accept the taken user choice 
    #F_WIPEPART userdata ni

    F_MSG 600 "    KDZ flashing completed.\n    Check the log for details (Advanced Menu)"
    F_LOG "$FUNCNAME: ended"
}; export -f F_FLASHKDZ

# choose and flash partitions from a backup or extracted KDZ
F_FLASHPART(){ F_LOG "$FUNCNAME: started"
    # takes 1 optional argument
    #
    # 1 => image files path

    if [ -z "$1" ];then
        AIMGDIR=$($FYAD --width=600 --title="$YTITLE - FOLDER" --form \
                    --field="  Select the source folder":DIR \
                  $HOME)
        IMGDIR=$(echo $AIMGDIR|cut -d '|' -f1)
    else
        IMGDIR="$1"
    fi

    F_LOG "$FUNCNAME: IMGDIR=$IMGDIR"

    [ ! -d "$IMGDIR" ] && F_ERR $FUNCNAME 3 "\n  ERROR!\n\n Folder \n\n  $IMGDIR\n\n  does not exists?!"

    # check device connection
    F_CHKDEVCON    
    VARSET=$(F_USUVARVALID)
    if [ "$VARSET" -eq 0 ];then F_MSGE 500 "ERROR: Cannot determine UsU state?! aborted.."; F_EXIT "$FUNCNAME" 3; fi
    
    # create a list of *.image files and let the user choose
    IMGFILES=$(for ifile in $(find "$IMGDIR" -maxdepth 1 -type f -name '*.bin' -or -name '*.img' -or -name '*.image' -or -name '*.mbn' | tr " " "_" |egrep -vi "(GPT|firehose|zeros)");do echo "${ifile##*/}";done | tr "\n" " ")

    F_LOG "($FUNCNAME) image files: $IMGFILES"

    # give proper default choice for what to flash and what not
    shopt -s extglob
    unset IRES
    for f in $IMGFILES;do
        AVIMG="${f/:*}"
        APART=$(echo "${f/*:}" | sed -e 's/\.image//g;s/\.img//g;s/\.bin//g;s/\.mbn//g;s/mmcblk0p\(.*\)/\1/g')
        case $APART in
            ${PUNNEEDED})
              if [ -z "$IRES" ];then IRES="false\n${AVIMG}\n${APART}\nunneeded\n99"; else IRES="$IRES false\n${AVIMG}\n${APART}\nunneeded\n99" ;fi
            ;;
            ${PBOOTL})
              if [ -z "$IRES" ];then IRES="true\n${AVIMG}\n${APART}\nbootloader\n1"; else IRES="$IRES true\n${AVIMG}\n${APART}\nbootloader\n1" ;fi
            ;;
            ${PDEVICE})
              if [ -z "$IRES" ];then 
                IRES="false\n${AVIMG}\n${APART}</span>\n<span\tcolor='#ff0000'>dangerous</span>\n88"
              else 
                IRES="$IRES false\n${AVIMG}\n${APART}\n<span\tcolor='#ff0000'>dangerous</span>\n88"
              fi
            ;;
            ${PSYSTEM})
            if [ -z "$IRES" ];then
                IRES="true\n${AVIMG}\n${APART}\n<span\tcolor='#558000'>safe-to-flash</span>\n2"
            else
                IRES="$IRES true\n${AVIMG}\n${APART}\n<span\tcolor='#558000'>safe-to-flash</span>\n2"
            fi
            ;;
            *)
            if [ -z "$IRES" ];then
                IRES="true\n${AVIMG}\n${APART}\nunknown-type\n2"
            else
                IRES="$IRES true\n${AVIMG}\n${APART}\nunknown-type\n2"
            fi
            ;;
        esac
    done

    F_LOG "($FUNCNAME) created yad list: $IRES"

    CHOOSENP=$(for files in $IRES;do echo -e "$files" ;done \
                | $FYAD --height=800 --width=700 --title="$YTITLE - FOLDER" --text "\n  Select the partitions you want to flash\n  (the RECOMMENDED partitions to flash are CHECKED already!)\n\n  Hint: you can change the target partition here but do this only when you\n  <b>REALLY KNOW</b> what you're doing!\n" --list --checklist \
                        --column="Flash":CHK --column="Image File":TXT --column="Target partition" --column="Type" --editable --editable-cols="3" --column=sort_int --hide-column=5  --listen  \
                        --button=FLASH:0 --button=Abort:99 |cut -d "|" -f 2-3,5 | tr "|" ":" )

    CHCOUNT=$(echo "$CHOOSENP" |tr " " "\n" |grep -c :)
    [ $CHCOUNT -lt 1 ] && F_ERR $FUNCNAME 0 "No partition selected?"

    F_LOG "choosen partitions: $CHOOSENP -> $CHCOUNT"

    SORTEDP=$(echo "$CHOOSENP" |tr " " "\n" | sort -t : -k 3n | cut -d ":" -f 1-2 | tr "\n" " " )
    CHCOUNT=$(echo "$SORTEDP" |tr " " "\n" |grep -c :)

    F_LOG "sorted partitions: $SORTEDP -> $CHCOUNT"

    UANS=$(F_MSGW 700 "Will flash these partitions:\n\n$(echo $SORTEDP|tr ' ' '\n')" "--button=FLASH:99")
    if [ $UANS -ne 99 ] || [ $CHCOUNT -eq 0 ] ;then
        F_MSGE 500 "Aborted by user or no partitions selected"
    else
        # FLASH
        CNT=0
        for img in $SORTEDP; do
            CNT=$((CNT+1))
            FFILE="$IMGDIR/${img/:*}"
            FPART=${img/*:}
            F_LOG "flashing: $FFILE to $FPART"
    
      # inform yad which partition we flash
      echo "#flashing: $FPART"
    
            F_LOG "$FUNCNAME: $FPART starting"
            $PYTHONBIN -u $LAFPATH/partitions.py ${CROPT} --batch --restore "$FFILE" $FPART 2>>$LOG | sed -u -e "s%:\([0-9]*\):\([0-9]*\)%,#$FPART: \1 KB / \2 KB%g;s/,/\n/g"  2>>$LOG
      FLASHERR=${PIPESTATUS[0]}
      if [ $FLASHERR -eq 0 ];then
        echo "100"
                    F_LOG "$FUNCNAME: $FPART finished"
                    [ $CNT -eq $CHCOUNT ] && echo '# ALL PARTITIONS FLASHED SUCCESSFULLY' && F_LOG "$FUNCNAME: All partitions flashed successfully"
      else
                    F_LOG "$FUNCNAME: $FPART FAILED with $FLASHERR"
        echo "# $FPART: FAILED"
              F_ERR $FUNCNAME 4 "\n  ERROR!\n\n  DO NOT REBOOT YOUR DEVICE!\n  FLASHING PROBLEM OCCURED!!!\n  while flashing:\n\n  <b>$FPART</b>" 
      fi
        done | $FYAD --title="$YTITLE - FLASHING" --text="\n  <b>SALT is now flashing...</b>\n  (if the progress bar does NOT get up to 100%: DO NOT REBOOT THE DEVICE!)\n\n" --width 900 --progress --button='Close (WAIT until all is flashed)':1
        FLERR=${PIPESTATUS[0]}
    
        # check result
        if [ "$FLERR" -eq 0 ];then
            F_MSGOK 400 "Flashing was successful!"
        else
            F_MSGE 400 "FLASHING ENDED WITH ERROR: $FLERR\n\nCheck Debug Log in SALT main screen!\nDO NOT REBOOT THE DEVICE TO AVOID HARD BRICK!!!!"
        fi
    
        # wipe cache
        #F_WIPEPART cache ni || F_MSGE 400 "Wiping cache ended with an error: $WIPERR\n\nCheck Debug Log in SALT main screen."
        
        # sync filesystems
        F_SYNC || F_MSGE 400 "Syncing filesystems ended with an error: $WIPERR\n\nCheck Debug Log in SALT main screen.\nDO NOT REBOOT THE DEVICE!"
    fi
    F_LOG "$FUNCNAME: ended"
}; export -f F_FLASHPART

# check/ensure device is connected
F_CHKDEVCON(){ F_LOG "$FUNCNAME: started"
    # takes no argument
    $PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  uname -m\0' --rawshell 2>&1 >> $LOG 
    RET=${PIPESTATUS[0]}
    if [ $RET -ne 0 ];then
        RES=$(F_MSG 700 "NO DEVICE CONNECTED?\nIf you have connected your device ensure that it is in DOWNLOAD mode\n(<u>not</u> fastboot, <u>not</u> recovery, <u>not</u> booted Android)" "--image=$SICONS/warning_64x64.png --button=Example-Picture:99 --button=Skip:11 --button=Retry:22")
        F_LOG "$FUNCNAME: msge result = $RES"
        F_LOG "$FUNCNAME: lsusb output = $(lsusb |grep 1004)"
        [ $RES -eq 99 ] && [ ! -z $SUDO_USER ] && sudo -u $SUDO_USER xdg-open "$SICONS/dlmode.png"
        [ $RES -eq 99 ] && [ -z $SUDO_USER ] && xdg-open "$SICONS/dlmode.png"
        RET=$RES
    else
        F_LOG "$FUNCNAME: Device seems to be connected!"
    fi
    F_LOG "RET: $RET"
    return $RET
}; export -f F_CHKDEVCON

# open a shell
F_SHELL(){ F_LOG "$FUNCNAME: started"
    # takes no arguments

    F_CHKDEVCON
    if [ $? -eq 0 ];then
        F_ELOG "device connected... Opening shell now!"
        xterm -e "cd $LAFPATH && echo -e '\n*****************\nTYPE the word exit TO CLOSE THIS WINDOW\n*********************\n\n'; $PYTHONBIN $LAFPATH/lglaf.py ${CROPT}"
    fi
    F_LOG "$FUNCNAME: ended"
}; export -f F_SHELL

# start dialog for kdz extract
F_STARTKDZ(){ F_LOG "$FUNCNAME: started"
    # takes no arguments

    EXCHOICES=$($FYAD --title="$YTITLE - EXTRACT" --width=800 --always-print-result --text \
        "\n  This will extract any KDZ file for you with just a click\n" \
        --form \
        --field="  KDZ file":FL --file-filter="KDZ files (*.kdz)| *.kdz *.KDZ"\
        --field="  Target directory\nHINT: Ensure you have enough free disk space":DIR \
        undef /tmp/salt_kdz \
        )
    F_ELOG "returned: $EXCHOICES"
    KDZFILE=$(echo "$EXCHOICES" | cut -d '|' -f 1)
    TARGDIR=$(echo "$EXCHOICES" | cut -d '|' -f 2)
    UDATA=$(echo "$EXCHOICES" | cut -d '|' -f 4)
    KCACHE=$(echo "$EXCHOICES" | cut -d '|' -f 5)
    
    F_ELOG "KDZFILE = $KDZFILE, TARGDIR = $TARGDIR, UDATA = $UDATA, KCACHE = $KCACHE"

    [ ! -f "$KDZFILE" ] && F_ERR "EXTRACTKDZ" 3 "$KDZFILE does not exists or is not readable!"
    [ ! -z "$TARGDIR" ] && [ ! -d "$TARGDIR" ] && echo mkdir -p $TARGDIR

    F_EXTRACTKDZ "$KDZFILE" "$TARGDIR" $UDATA $KCACHE

    F_ELOG $FUNCNAME ended
};export -f F_STARTKDZ

# Update everything!
F_UPDATE(){ F_LOG "$FUNCNAME: started"
    # takes no arguments
    #

    # let the user switch between stable and develop
    AA=$($FYAD --title="$YTITLE - SETUP" --item-separator='|' --text "\n  Here you can choose between stable and development branches of SALT and its backends" --form \
            --field="  SALT branch\t":CBE "$BRSALT|$BROSALT" \
            --field="  kdztools branch\t":CBE "$BRKDZ|$BROKDZ" \
            --field="  lglaf branch\t":CBE "$BRLAF|$BROLAF"\
            --button=Update:0 --button=Cancel:1 \
         )

    [ $? -ne 0 ] && F_LOG "Aborted on user request" && F_EXIT $FUNCNAME 4

    BRSALT=$(echo "$AA"| cut -d "|" -f 1)
    BRKDZ=$(echo "$AA"| cut -d "|" -f 2)
    BRLAF=$(echo "$AA"| cut -d "|" -f 3)

    CNT=0
    for u in ${SALTPATH}:$BRSALT ${LAFPATH}:$BRLAF ${KDZTOOLS}:$BRKDZ; do 
        CNT=$((CNT+1))
        F_LOG "$FUNCNAME: updating ${u/:*} on branch ${u/*:} ..."
        echo "${CNT}:5"
        cd ${u/:*}
        echo "${CNT}:10"
        F_LOG "$($GIT checkout ${u/*:} 2>&1)"
        $GIT pull 2>&1 | tee -a $LOG | sed "s/^/${CNT}:#/g"
        test ${PIPESTATUS[0]} -eq 0 && echo "${CNT}:100"
    done | $FYAD --title="$YTITLE - UPDATING" --text="\n  <b>Be patient while SALT freshen up...</b>\n  (if a progress bar do NOT get to 100% a manual update is required)\n\n" --width 800 --multi-progress --bar="SALT codebase":norm --bar="LGLAF codebase":norm --bar="kdztools codebase":norm --button=Close

    F_MSGW 600 "You must restart SALT if you have updated or changed the <b>SALT</b> branch before the changes become active." "--fixed"
    F_LOG "$FUNCNAME: ended"
}; export -f F_UPDATE

# wipe a partition
F_WIPEPART(){ F_LOG "$FUNCNAME: started with $@"
    # takes 2 arguments
    #
    # 1 => partition name to wipe
    # 2 => interactive (ia) or noninteractive (ni) mode. if not given we assume interactive!

    WPART="$1"
    ITP="$2"

    if [ "$ITP" == "ni" ];then 
        F_LOG "$FUNCNAME: wiping $WPART in noninteractive mode"
        $PYTHONBIN ${LAFPATH}/partitions.py ${CROPT} --wipe $WPART 2>&1 | tee -a $LOG
    else
        F_LOG "$FUNCNAME: wiping $WPART in interactive mode"
        F_MSG 400 "Do you really want to wipe out <b>$WPART</b>?" "--button=Yes:0 --button='wtf NO never':1"
        [ $? -eq 0 ] && $PYTHONBIN ${LAFPATH}/partitions.py ${CROPT} --wipe $WPART 2>&1 | tee -a $LOG | $FYAD --title="$YTITLE - WIPING" --width=800 --height=200 --text-info --listen --wrap --button=Close
    fi
    F_SYNC
}; export -f F_WIPEPART

# execute commands via lglaf
F_LAFEXEC(){ F_LOG "$FUNCNAME: started with these arguments: $@"
    # takes 1 argument

    EXECMD="$1"
    RET=$($PYTHONBIN ${LAFPATH}/lglaf.py ${CROPT} -c "'!EXEC  ${EXECMD}\0'" --rawshell)
    echo $RET
}; export -f F_LAFEXEC

# flush file system buffers
F_SYNC(){ F_LOG "$FUNCNAME: started"
    # takes no arguments

    F_LAFEXEC sync
}; export -f F_SYNC

# take a nandroid backup of the device
F_BACKUP(){ F_LOG "$FUNCNAME: started with these arguments: $@"
    # takes no arguments

    # define backup type
    $FYAD --width=550 --image="$SICONS/backup.png" --title="$YTITLE - BACKUP" --text "\n  Choose your backup type!\n\n  Basic:\twill just backup partitions up to a size of $BMAXDEF MB\n  Full:\tlike Basic but includes any size" --button=Full:1 --button=Basic:2 --buttons-layout=center
    BAKTYPE=$?

    COMPLSIZE=0
    case $BAKTYPE in
        1) BAKTNAME=Full
            BMAX=0
            for size in $($PYTHONBIN ${LAFPATH}/partitions.py ${CROPT} --list --batch | cut -d ":" -f6 | $TRBIN "\n" " ");do
                COMPLSIZE=$((COMPLSIZE + $size))
            done
        ;;
        2) BAKTNAME=Basic
            BMAX=$((BMAXDEF * 1024))
            for size in $($PYTHONBIN ${LAFPATH}/partitions.py ${CROPT} --list --batch | cut -d ":" -f6 | $GREPBIN -v $BMAX | $TRBIN "\n" " ");do
                if [ $size -le $BMAX ];then
                    F_LOG "$FUNCNAME: DEBUG: adding $size to $COMPLSIZE"
                    COMPLSIZE=$((COMPLSIZE + $size))
                else
                    F_LOG "$FUNCNAME: skipping $size as its smaller then $BMAX"
                fi
            done
        ;;
        *) F_EXIT $FUNCNAME $BAKTYPE
        ;;
    esac
    COMPLSIZEMB=$((COMPLSIZE / 1024))
    F_LOG "$FUNCNAME: choosen backup type was $BAKTYPE, $BAKTNAME, $BMAX KB, backup size: $COMPLSIZEMB"

    TFREE=0
    while [ "$TFREE" -lt "$COMPLSIZEMB" ];do
        BANS=$($FYAD --width=800 --image="$SICONS/backup.png" --title="$YTITLE - BACKUP" --text="\n Backup your device in <b>$BAKTNAME</b> mode.\n\n The choosen backup type will require: <span color='#ff0000'><b>$COMPLSIZEMB MB</b></span> of free disk space!\n\n" --form \
        --field="Target directory":CDIR "${REALHOME}/salt_backup" \
        --button=Continue:0 --button=Abort:99)
        BRET=$?
        [ $BRET -ne 0 ] && F_EXIT "$FUNCNAME Aborted on users request" $BRET
        BTDIR="${BANS/|*}"
        F_LOG "$FUNCNAME: choosen target directory was $BTDIR"

        [ ! -d "$BTDIR" ] && F_LOG "$FUNCNAME: Target dir <$BTDIR> does not exists. Will create it" && mkdir -p "$BTDIR"

        # verify disk space
        TFREE=$(F_CHKFREE "$BTDIR")
        F_LOG "$FUNCNAME: TFREE $TFREE vs. $COMPLSIZEMB"
        [ "$TFREE" -lt "$COMPLSIZEMB" ] && F_MSGE 500 "Wake up dude!\n\nThe target directoy:\n\n$BTDIR\n\n<span color='#ff0000'><b>HAS NOT ENOUGH FREE SPACE!</b></span>\n\nFree space:\t<b>$TFREE MB</b>\nRequired:\t<b>$COMPLSIZEMB MB</b>\n\nTry again!"
    done

    F_LOG "$FUNCNAME: Target directory has enough free space!"
    $FYAD --width=500 --image="$SICONS/backup.png" --title="$YTITLE - BACKUP" --text "\n  READY!\n\n  Free space:\t<b>$TFREE MB</b>\n  Required:\t<b>$COMPLSIZEMB MB</b>\n\n  Click START to begin the backup now. " --button=START:0 --button=Abort:2
    BRET=$?
    [ $BRET -ne 0 ] && F_EXIT "$FUNCNAME Aborted on users request" $BRET

    $PYTHONBIN ${LAFPATH}/extract-partitions.py ${CROPT} --batch --outdir $BTDIR --max-size $BMAX 2>&1 | tee -a $LOG | $FYAD --title="$YTITLE - $BAKTNAME BACKUP" --text="\n  <b>SALT is backing up your device...</b>\n\n" --width 900 --progress --button='Close (WAIT until you see All finished)':0
    BERR=${PIPESTATUS[0]}
    if [ "$BERR" -ne 0 ];then
        F_MSGE 500 "Backup incomplete! Check the log."
    else
        F_MSGOK 400 "Backup completed successfully"
    fi

    # ensure regular users can work with the backup
    chown -Rv ${REALUSER} "${REALHOME}/salt_backup" >> $LOG

    VERSUPP=$($PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  md5sum /dev/block/bootdevice/by-name/\0' --rawshell 2>&1 | cut -d ' ' -f 1 | grep -vi Hello)
    if [ -z "$VERSUPP" ];then
        F_MSGW 600 "\n  Your device/firmware does not support verification of the backup sorry." 
    else
        unset VERANS
        VERANS=$(F_MSGOK 600 "\n  Your device supports md5sum verification!\n  Do you want to verify your just created backup?" "--button=Verify:2")
        F_LOG "$FUNCNAME: VERANS was $VERANS"
        [ "$VERANS" == "2" ] && F_VERIFYBAK "$BTDIR"
    fi
}; export -f F_BACKUP

# verify a backup folder with reality
F_VERIFYBAK(){ F_LOG "$FUNCNAME: started"
    # takes 1 argument
    #
    # mandantory:
    # 1 => path to the backup images (can be img,image,bin,mbn,mmcblk0p* files)

    VDIR=$1
    [ ! -d "$VDIR" ] && F_MSGE 650 "$VDIR does not exists!\nHow am I supposed to use these files existing only in your head?" && F_EXIT "$FUNCNAME no VDIR" 3

    DIRFILES=$(for v in $(find "$VDIR" -maxdepth 1 -type f -name '*.bin' -or -name '*.img' -or -name '*.image' -or -name 'mmcblk0p*' -or -name '*.mbn' | tr " " ","); do echo "$v";done)

    F_LOG "$FUNCNAME: detected files: $DIRFILES"
    CHCOUNT=$(echo "$DIRFILES" | egrep -c '^.+')
    F_LOG "$(echo \"$DIRFILES\" | egrep -c '^.+')"
    F_LOG "detected files: $DIRFILES -> $CHCOUNT"

    [ $CHCOUNT -lt 1 ] && F_MSGE 400 "$FUNCNAME: No valid image files found\n(valid are: bin, img, image, mbn, mmcblk0p*)!" && F_EXIT "$FUNCNAME: exited" 3


    SORTEDF=$(echo "$DIRFILES" |tr " " "\n" | sort | tr "\n" " " )
    CHCOUNT=$(echo "$SORTEDF" |tr " " "\n" |egrep -c '^.+')

    F_ELOG "sorted partitions: $SORTEDF -> $CHCOUNT"

    CNT=0
    BAKOK=()
    BAKWARNING=()
    BAKERROR=()

    # open yad listener
    echo 0> /tmp/t 
    tail -f /tmp/t | $FYAD --title="$YTITLE - VERIFY" --text="\n  <b>SALT is now verifying the backup...</b>\n  (just wait until you see: <b><span color='#ff0000'>VERIFICATION FINISHED</span></b>)\n" --width 900 --progress --button='Close (WAIT until FINISHED)':0 --auto-close &
    tail_pid=$!

    for vfile in $SORTEDF;do
        CNT=$((CNT+1))
        vfileloc=$(echo "${vfile}"| tr "," " ")
        echo "#${vfileloc/*\/} generating md5 ..." >>/tmp/t
        LOCFILE=$(md5sum "$vfileloc" | cut -d " " -f1)
        echo "#${vfileloc/*\/} md5: $LOCFILE" >>/tmp/t
        vfilerem=$(echo "${vfileloc/*\/}" | tr "," " " | sed -e 's/\.image//g;s/\.img//g;s/\.mbn//g;s/\.bin//g')
        F_LOG "$FUNCNAME: vfile: ${vfile}, vfileloc: $vfileloc, LOCFILE: $LOCFILE, vfilerem: $vfilerem"

        if [ -z "$vfilerem" ];then
            vfilerem=$(echo "${vfileloc}" | tr "," " " | sed -e 's/mmcblk0p\(.*\)/\1/g')
            REMFILE=$($PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  md5sum /dev/block/bootdevice/by-num/p'${vfilerem}'\0' --rawshell 2>&1 | cut -d ' ' -f1)
        else
            LAFEXEC='!EXEC  md5sum /dev/block/bootdevice/by-name/${vfilerem}\0'
            REMFILE=$($PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  md5sum /dev/block/bootdevice/by-name/'${vfilerem}'\0' --rawshell 2>&1 | cut -d ' ' -f1)
        fi
        F_LOG "$FUNCNAME: vfilerem: $vfilerem, REMFILE: $REMFILE"
        if [ -z "$LOCFILE" -o -z "$REMFILE" ];then
            F_LOG "$FUNCNAME: ${vfile/*\/} verify not possible as one or both hashes are empty (LOCFILE: $LOCFILE , REMFILE: $REMFILE)!"
            echo "#${vfile/*\/} no md5 verify!">>/tmp/t
            BAKWARNING+=("${vfile/*\/}\n")
        else
            if [ "$LOCFILE" == "$REMFILE" ];then
                F_LOG "$FUNCNAME: ${vfile/*\/} verify OK ($LOCFILE == $REMFILE)!"
                echo "#${vfile/*\/} verify OK!">>/tmp/t
                BAKOK+=("${vfile/*\/}\n")
                F_LOG "${BAKOK[@]}"
            else
                F_LOG "$FUNCNAME: #${vfile/*\/} verify ERROR (($LOCFILE != $REMFILE))!"
                echo "#${vfile/*\/} verify ERROR!" >>/tmp/t
                BAKERROR+=("${vfile/*\/}\n")
            fi
        fi
        # ensure we do not overflow lafd
        sleep 2
        CNTPERC=$(($CNT * 100 / $CHCOUNT))
        echo $CNTPERC >>/tmp/t
        [ $CNT -eq $CHCOUNT ] && echo '# VERIFICATION FINISHED!' >>/tmp/t && F_LOG "$FUNCNAME: Verification finished"
    done
    # close yad listener
    kill $tail_pid

    F_LOG "Success\n${BAKOK[@]}\nWarning\n${BAKWARNING[@]}\nErrors\n${BAKERROR[@]}"
    F_LOG "Success(#): ${#BAKOK[@]}, Warnings(#): ${#BAKWARNING[@]}, Errors(#): ${#BAKERROR[@]}"
    BAKOKYAD=$(echo "${BAKOK[@]}")
    BAKWARNYAD=$(echo "${BAKWARNING[@]}")
    BAKERRYAD=$(echo "${BAKERROR[@]}")
    $FYAD --title="$YTITLE - BAK VERIFY" --width=600 --center --text="\n\tVerifying completed!\n\tClick on the corresponding buttons to display details\n\n" --form \
            --field="\t${#BAKOK[@]}":RO OK \
            --field="\t${#BAKWARNING[@]}":RO WARNING \
            --field="\t${#BAKERROR[@]}":RO ERROR \
            --field=Details:FBTN "$FYAD --image=$SICONS/ok_64x64.png --width=800 --title=\"$YTITLE - OK\" --text=\"\nThese partitions were successfully verified (md5 matched):\n\n ${BAKOKYAD}\" --button=Close" \
            --field=Details:FBTN "$FYAD --image=$SICONS/warning_64x64.png --width=800 --title=\"$YTITLE - WARNINGS\" --text=\"\nThese files cant be verified (no md5 on partition possible):\n\n ${BAKWARNYAD}\" --button=Close" \
            --field=Details:FBTN "$FYAD --image=$SICONS/error.png --width=800 --title=\"$YTITLE - ERRORS\" --text=\"\nThese files are corrupt (md5 mismatch):\n\n ${BAKERRYAD}\" --button=Close" \
            --columns=2 --button=Close
}; export -f F_VERIFYBAK

# check if we run already and if not create a lock 
F_EGO(){ F_LOG "$FUNCNAME: started"
    # takes no arguments

    FRET=1
    [ -f $LOCKFILE ] && FRET=$(F_MSG 500 "\n  Oops... SALT seems to be running already!\n  Do you want me to ignore this (not recommended)?" "--image=$SICONS/error.png --button=Ignore:1 --button=Close:0")
    [ $FRET -ne 1 ] && F_LOG "$FUNCNAME: Aborted on users request" && exit 123  # no regular F_EXIT here
    # create a lock file
    date > $LOCKFILE && F_LOG "$FUNCNAME: $LOCKFILE created"
}; export -f F_EGO

# about/support screen
F_ABOUT(){ F_LOG "$FUNCNAME: started"
    # takes no args

    $FYAD --image="$SICONS/salt_logo_128x128.png" --title="$YTITLE - ABOUT" --width=800 --height=500 --fixed --text \
"\n  $TNAME is based on:\n\t- <a href='https://sourceforge.net/projects/yad-dialog'>YAD</a> - without this no GUI\n\
\t- the awesome <a href='https://github.com/Lekensteyn/lglaf'>LGLAF</a> code by Peter Wu\n\
\t- <a href='https://github.com/ehem/kdztools'>kdztools</a> by Elliott Mitchell\n\
\t- <b>MANY</b> enhancements by steadfasterX (including this GUI)\n\n\
  ${TNAME} sources:\n\
\t- <a href='https://github.com/steadfasterX/salt'>$TNAME</a>\n\
\t- <a href='https://github.com/steadfasterX/lglaf'>Patched LGLAF</a>\n\
\t- <a href='https://github.com/steadfasterX/salt'>Patched kdztools</a>\n\n\
  $TNAME support: <a href='https://tinyurl.com/SALTatXDA'>XDA thread</a>\n\n\
  Special credits:\n\
\t- <a href='https://github.com/tuxuser/'>tuxuser</a> for making LAF communication on Nougat possible and for his great support!\n\n\
  Images/Icons:\n\
\t- SALT logo is created by <a href='https://github.com/steadfasterX'>steadfasterX</a> and licensed under <a href='https://creativecommons.org/licenses/by-sa/4.0/'>CC BY-SA 4.0</a>.\n\
\t- CR icon by RRZEicons <a href='https://creativecommons.org/licenses/by-sa/3.0'>CC BY-SA 3.0</a> from Wikimedia Commons. Modified in size." \
        --button=Close:0
}; export -f F_ABOUT

# flash a kdz
F_STARTKDZFL(){ F_LOG "$FUNCNAME: started"
    # takes no args

    FLCHOICES=$($FYAD --title="$YTITLE - FLASH" --always-print-result --width=800 --text "\n  When proceeding you accept that there is no guarantee for nothing - nowhere.\n  I do my best to avoid problems but we all are humans right?\n  You do this on your own responsibility and own risk no matter what.\n\n  Select a KDZ file to flash:" --form \
        --field="":FL --file-filter="KDZ files (*.kdz)| *.kdz *.KDZ" \
        --field="\n":LBL \
        --field="Factory Reset\t(if  *unchecked*  may result in bootloop)":CHK \
        --field="Model Check\t(if  *unchecked*  may result in HARD BRICK)":CHK \
        --field="ARB Check\t(if  *unchecked*  may result in HARD BRICK)":CHK \
        --field=:LBL \
        --field="TEST run\t\t(will  *not*  flash anything)":CHK \
        undef true true true true true true\
        --button="Agree &amp; Continue":0 \
        --button="Cancel":1 \
        )
    FLERR=$?
    [ $FLERR -ne 0 ] && F_EXIT flashing-select $FLERR 
 
    LGKDZ=$(echo "$FLCHOICES" | cut -d '|' -f 1)
    LGFR=$(echo "$FLCHOICES" | cut -d '|' -f 3)
    LGCHKMOD=$(echo "$FLCHOICES" | cut -d '|' -f 4)
    LGARB=$(echo "$FLCHOICES" | cut -d '|' -f 5)
    LGDRY=$(echo "$FLCHOICES" | cut -d '|' -f 7)

    F_ELOG "LGKDZ = $LGKDZ, LGFR = $LGFR, LGCHKMOD = $LGCHKMOD, LGARB = $LGARB, LGDRY = $LGDRY"

    [ ! -f "$LGKDZ" ] && F_ERR flashing-kdz-invalid 3 "\n  <b>ERROR</b>\n\n  The file\n  $LGKDZ\n  does not exist!\n"

    F_CHKDEVCON
    if [ $? -eq 0 ];then
        F_ELOG "device connected... going on!"
        F_FLASHKDZ "$LGKDZ" "$LGFR" "$LGCHKMOD" "$LGARB" "$LGDRY"
    else
        F_MSG 600 "\n  ERROR!\n\n  NO DEVICE CONNECTED?\n  If you have connected your device ensure that it is in DOWNLOAD mode\n  (not fastboot, not recovery, not booted Android)" "--button=Return:0"
    fi
}; export -f F_STARTKDZFL

# showing a advanced menu
F_ADVMENU(){ F_LOG "$FUNCNAME: started with $@"
    # takes 1 arg
    #
    # 1 => LGMODEL
    
    LGMODEL=$1
    F_LOG "$FUNCNAME: main YAD_PID is $YAD_PID"

    $FYAD --title="$YTITLE" --width=1000 --image="$SICONS/salt_logo_128x128.png" --text "\n  <b>$TFULLNAME</b>\n\n <b><span color='#ff0000'>THIS IS AN ADVANCED Menu</span></b>\n\nUse these options here with <b><span color='#ff0000'>CARE!</span></b>\n\n(mouse-over on a button for details)\n" \
        --form --columns=2\
        --field="SALT debug log!$SICONS/log_16x16.png":FBTN "$SALTPATH/getlog" \
        --field="$CRBTN!$SICONS/cr_30x30.png!Change the detection of challenge/response: Auto, forced yes, forced no":FBTN "bash -c 'F_CRRESTART $YAD_PID $CRMODE'" \
        --field="Convert an image (ZIP)!!Extract and convert sparse Android data images (.dat/.br) into a readable filesystem image and mount it":FBTN "bash -c F_EXTRACTDAT" \
        --field="Mount an image file!!This will let you mount android image files (system,userdata,..)":FBTN "bash -c F_MOUNTPARTS" \
        --field="Open a shell!$SICONS/terminal_30x30.png!Open an adb-like shell while in download mode":FBTN "bash -c F_SHELL" \
        --field="<span color='#ff0000'>Wipe</span> partition(s)!!EXTREMELY DANGEROUS - CAN EASILY BRICK YOUR DEVICE":FBTN "bash -c F_DELPART" \
        --field="Show your partitions!!This will just list your current partitions":FBTN "bash -c F_LISTPARTS" \
        --field="Unlock G4 (UsU)!$SICONS/salt_logo_30x30.png!Unofficial secureboot-off/steadfasterX Unlock":FBTN "bash -c 'F_DOUSU $LGMODEL'" \
        --button="Support / Licensing / Credits!$SICONS/log_16x16.png":"bash -c F_ABOUT" \
        --button="Close"

}; export -f F_ADVMENU

# mount a partition menu
F_MOUNTPARTS(){ F_LOG "$FUNCNAME: started"
    # takes 1 arg
    #
    # optional:
    # 1 => full path to image file
    
    ISRC=undef
    [ ! -z "$1" ] && ISRC="$1/click-here-2-select-a-file"
 
    CHOICE=$($FYAD --title="$YTITLE - MOUNT" --width=800 --always-print-result --text \
        "\n  Choose your image file you want to mount\n" \
        --form \
        --field="  Image file":FL --file-filter="Image (*.img)| *.img *.IMG *.bin *.mbn *.image" "$ISRC"\
        --field="  Mountpoint (don't touch unless you know why)" "/mnt/salt_mnt" \
        --button=Abort:99 \
        --button=Next:0 \
        )
    [ $? -eq 99 ] && F_MSGW 500 "Aborted by user" && F_EXIT $FUNCNAME 42

    F_LOG "returned: $CHOICE"
    IMGFILE=$(echo "$CHOICE" | cut -d '|' -f 1)
    MNTPNT=$(echo "$CHOICE" | cut -d '|' -f 2)

    F_LOG "IMGFILE = $IMGFILE, MNTPNT = $MNTPNT"

    [ ! -f "$IMGFILE" ] && F_ERR "$FUNCNAME" 3 "$IMGFILE does not exists or is not readable!"

    F_MOUNTIMG "$IMGFILE" "$MNTPNT"
  
}; export -f F_MOUNTPARTS

# sparse Android data image (.dat) and it's transfer list 
F_EXTRACTDAT(){ F_LOG "$FUNCNAME: started"
    # takes no args

    EXCHOICES=$($FYAD --title="$YTITLE - Choose ROM" --width=800 --always-print-result --text \
        "\n  Choose your ROM zip file\n" \
        --form \
        --field="  ROM zip file":FL --file-filter="ROM (*.zip)| *.zip *.ZIP" undef\
        --field="  Working directory":DIR "/tmp" \
        --field="  Auto-Mount resulting image file":CHK true \
        --field="  Mountpoint (don't touch unless you know why)" "/mnt/android_image" \
        --button=Abort:99 \
        --button=Next:0 \
        )
    [ $? -eq 99 ] && F_MSGW 500 "Aborted by user" && F_EXIT $FUNCNAME 42

    F_LOG "returned: $EXCHOICES"
    ZIPFILE=$(echo "$EXCHOICES" | cut -d '|' -f 1)
    TARGDIR=$(echo "$EXCHOICES" | cut -d '|' -f 2)
    MNTWANT=$(echo "$EXCHOICES" | cut -d '|' -f 3)
    CMNTPNT=$(echo "$EXCHOICES" | cut -d '|' -f 4)

    F_ELOG "ZIPFILE = $ZIPFILE, TARGDIR = $TARGDIR"

    [ ! -f "$ZIPFILE" ] && F_ERR "$FUNCNAME" 3 "$ZIPFILE does not exists or is not readable!"
    [ ! -z "$TARGDIR" ] && [ ! -d "$TARGDIR" ] && echo mkdir -p $TARGDIR

    EXCHOICES2=$(for i in $(unzip -Z1 "$ZIPFILE" '*.new*');do echo -e "false\n${i}" ;done | $FYAD --title="$YTITLE - Choose DAT" --width=800 --always-print-result --text \
        "\n  The following dat file(s) has/have been found in your zip file\n  Choose the system dat file you wanna extract and convert\n" \
        --list --radio-list \
        --column="Selection":RD \
        --column="Filename" \
        --print-column=2 \
        --button=Abort:99 \
        --button=Next:0
        )
    [ $? -eq 99 ] && F_MSGW 500 "Aborted by user" && F_EXIT $FUNCNAME 42
    F_LOG "returned: $EXCHOICES2"

    EXFILE=$(echo "$EXCHOICES2" | cut -d '|' -f 1)
    BRC=$(echo "$EXFILE" |grep -c "\.br")
    if [ "$BRC" -eq 1 ];then
        if [ ! -f "$BROTLI" ];then
            F_MSGE 500 "You're trying to extract an Oreo 8.1 dat file\nwhich requires the Google tool <a href='https://github.com/google/brotli'>brotli v1.x or higher!!!</a>\n\nPlease install it first:\n\n\t- in FWUL/Arch/Manjaro:\n\t  sudo pacman -S brotli\n\n\t- on Ubuntu/Debian/Mint:\n\t  sudo apt-get install brotli" "--selectable-labels --height=400 --fixed"
            F_EXIT $FUNCNAME 3
        else
            F_LOG "Brotli required and found!"
        fi
    fi

    [ -z "$EXFILE" ] && F_MSGE 500 "No file choosen?!"

    CHIMGNAME="${EXFILE/\.*}"
    MNTPNT="${CMNTPNT}_$CHIMGNAME"

    F_LOG "ZIPFILE = $ZIPFILE, TARGDIR = $TARGDIR, EXFILE = $EXFILE, CHIMGNAME = $CHIMGNAME, MNTPNT = $MNTPNT"

    F_UNZIP "$ZIPFILE" "$TARGDIR" "$EXFILE ${CHIMGNAME}.transfer.list"
    if [ $BRC -eq 0 ];then
         F_CONVDAT "DAT" "${TARGDIR}/${CHIMGNAME}.transfer.list" "${TARGDIR}/$EXFILE" "$TARGDIR" "${CHIMGNAME}.converted.img"
    else
        F_CONVDAT "BR" "${TARGDIR}/${CHIMGNAME}.transfer.list" "${TARGDIR}/$EXFILE" "$TARGDIR" "${CHIMGNAME}.converted.img"
        F_CONVDAT "DAT" "${TARGDIR}/${CHIMGNAME}.transfer.list" "${TARGDIR}/${CHIMGNAME}.new.dat" "$TARGDIR" "${CHIMGNAME}.converted.img"
    fi
    if [ "$MNTWANT" == "TRUE" ];then
        F_MOUNTIMG "$TARGDIR/${CHIMGNAME}.converted.img" "$MNTPNT"
    else
        F_MSGOK 600 "Image has been extracted!\nYou can find it here:\n\n<b>${TARGDIR}/</b>"
    fi

    F_LOG "$FUNCNAME ended"
}; export -f F_EXTRACTDAT

# mounting a given image file
F_MOUNTIMG(){ F_LOG "$FUNCNAME: started with $@"
    # takes 2 args
    #
    # required:
    # 1 => filename to mount (full path)
    # 2 => mountpoint
    MFILE="$1"
    MPNT="$2"

    [ ! -f "$MFILE" ] && F_ERR "$FUNCNAME" 3 "$MFILE does not exists or is not readable!"
    [ ! -d "$MPNT" ] && F_LOG "$FUNCNAME: mountpoint $MPNT does not exits.. will be created now!" && mkdir -p $MPNT

    # check if the mnt point is in use
    mount | grep "$MPNT" >> /dev/null
    if [ $? -eq 0 ];then
        F_MSGE 500 "Mountpoint $MPNT is in use! Unmount it first!\n\nABORTED."
    else
        # mount
        mount -v -o loop "$MFILE" $MPNT 2>&1 >> $LOG 
        if [ $? -eq 0 ]; then
            $FYAD --width=1000 --image="$SICONS/salt_logo_128x128.png" --title="$YTITLE - MOUNT" --text="  Image file:\n\t<b>$MFILE</b>\n\n  has been mounted to\n\t<b>$MNTPNT</b>\n\n" \
                --form \
                --field="Browse Image":FBTN "sudo -u $REALUSER xdg-open $MPNT" \
                --field="Unmount Image":FBTN "bash -c 'F_UMNT $MPNT'" \
                --button=Close:0
        else
            F_MSGE 500 "system image could not be mounted to $MNTPNT.\nCheck SALT logfile!"
        fi
    fi
    F_LOG "$FUNCNAME ended"
};export -f F_MOUNTIMG

# unmount image/partitions, ..
F_UMNT(){ F_LOG "$FUNCNAME: started with '$@'"
    # takes 1 arg
    #
    # required:
    # 1 => mountpoint to unmount
    
    MPNT="$1"
    mount | grep "$MPNT" >> /dev/null
    if [ $? -eq 0 ];then
        umount -v "$MPNT" 2>&1 >> $LOG
        if [ $? -eq 0 ];then F_MSGOK 500 "$MPNT unmounted!"; else F_MSGE 500 "Error on unmounting!\nCheck logfile in the advanced menu!";fi
    else
        F_MSGE 500 "Sorry but there is no mountpoint:\n\n$MPNT"
    fi
}; export -f F_UMNT

# unzip files from a ZIP :P
F_UNZIP(){ F_LOG "$FUNCNAME: started with '$@'"
    # takes 3 args
    #
    # required:
    # 1 => ZIP filename
    # 2 => target directory
    #
    # optional:
    # 3 => file(s) to extract

    ZIPF="$1"
    TARGD="$2"
    ZFILE="$3"
    [ ! -f "$ZIPF" ] && F_ERR "$FUNCNAME" 3 "$ZIPF does not exists or is not readable!"
    if [ -z "$TARGD" ];then
        F_ERR "$FUNCNAME" 3 "Missing target dir!"
    else
        [ ! -d "$TARGDIR" ]&& echo mkdir -p "$TARGDIR"
    fi

    F_LOG "Will extract $ZFILE from $ZIPF to $TARGD (overwriting mode!)"

    unzip -o "$ZIPF" -d "$TARGD" $ZFILE 2>&1 | tee -a $LOG | $FYAD --title="$YTITLE - EXTRACT" --text="\n  Extracting:\n  <b>${ZIPF/*\/}</b>\n  Please be patient depending on your PC this can take a while...\n" --width=800 --progress --progress-text="extracting ${ZFILE} ..." --pulsate  --no-buttons --auto-close
    [ $? -ne 0 ] && F_MSGE 500 "Error $? occured / Aborted by user while extracting $ZFILE" && F_EXIT $FUNCNAME 3
    F_LOG "Extracting finished successfully"

}; export -f F_UNZIP

# convert an android sparse file
F_CONVDAT(){ F_LOG "$FUNCNAME: started with $@"
    # takes 4 args
    #
    # required:
    # 1 => BR (brotli) or DAT (sda2img) mode
    # 2 => transfer list (full path)
    # 3 => sparse filename (full path)
    # 4 => target directory
    # 5 => target image file name

    CMODE="$1"
    TFLIST="$2"
    SFIL="$3"
    TDIR="$4"
    IMGTYPE="${5/\.*}"
    RFILE="${TDIR}/$5"

    F_LOG "$FUNCNAME: $CMODE, $TFLIST, $SFIL, $TDIR, $RFILE, $IMGTYPE"
    [ ! -f "$TFLIST" -o ! -f "$SFIL" -o ! -d "$TDIR" ] && F_MSGE 500 "missing file! $TFLIST, $SFIL, $TDIR," && F_EXIT $FUNCNAME 3

    case "$CMODE" in
        DAT) F_LOG "DAT mode detected"
             $PYTHONBIN $SDATBIN "$TFLIST" "$SFIL" "$RFILE" 2>&1 | tee -a $LOG | $FYAD --title="$YTITLE - CONVERT" --text="\n  Converting:\n  <b>${SFIL/*\/}</b>\n  Please be patient depending on your PC this can take a while...\n" --width=800 --progress --progress-text="converting ${SFIL} ..." --pulsate --no-buttons --auto-close
        ;;
        BR) F_LOG "BR mode detected"
            $BROTLI --force --decompress -o "${TDIR}/${IMGTYPE}.new.dat" "$SFIL" 2>&1 | tee -a $LOG | $FYAD --title="$YTITLE - CONVERT" --text="\n  Converting:\n  <b>${SFIL/*\/}</b>\n  Please be patient depending on your PC this can take a while...\n" --width=800 --progress --progress-text="converting ${SFIL} ..." --pulsate --no-buttons --auto-close 
        ;;
        *) F_MSGE 500 "no valid mode selected! ABORTED"; F_EXIT $FUNCNAME 3
        ;;
    esac
    [ $? -ne 0 ] && F_MSGE 500 "Error $? occured / Aborted by user while converting $SFIL" && F_EXIT $FUNCNAME 3
    F_LOG "Converting finished successfully"
}; export -f F_CONVDAT

# list your partitions nicely
F_LISTPARTS(){ F_LOG "$FUNCNAME: started"
    # takes no args

    IRES=$(F_GETPARTS)

    for files in $IRES;do echo -e "$files" | egrep -vi "(true|false)" ;done | $FYAD --height=800 --width=1000 --title="$YTITLE - PARTITIONS" --text "\n  Your partitions:\n" --list \
            --column="Partition":TXT \
            --column="#" \
            --column="Start sector" \
            --column="End sector" \
            --column="UID" \
            --column="Type" \
            --column="Unused" \
            --listen --no-selection \
            --hide-column=7 \
            --button=Close:0 
}; export -f F_LISTPARTS

# show your partitions
F_GETPARTS(){ F_LOG "$FUNCNAME: started"
    # takes no args

    PARTLIST=$($PYTHONBIN $LAFPATH/partitions.py ${CROPT} --list --batch)

    # make preselections
    unset IRES
    for f in $PARTLIST;do

        PNAME="${f/:*}"
        PARTN=$(echo "${f}" | cut -d ":" -f 2)
        SSEC=$(echo "${f}" | cut -d ":" -f 3)
        ESEC=$(echo "${f}" | cut -d ":" -f 4)
        PARTUID=$(echo "${f}" | cut -d ":" -f 5)
    
        F_LOG "${PNAME},${PARTN},${SSEC},${ESEC},${PARTUID}"

        shopt -s extglob
        case $PNAME in
            ${PUNNEEDED})
              if [ -z "$IRES" ];then IRES="false\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\nunneeded\n99"; else IRES="$IRES false\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\nunneeded\n99" ;fi
            ;;
            ${PBOOTL})
              if [ -z "$IRES" ];then IRES="true\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\nbootloader\n1"; else IRES="$IRES true\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\nbootloader\n1" ;fi
            ;;
            ${PDEVICE})
              if [ -z "$IRES" ];then 
                IRES="false\n${PNAME}\n${PARTN}${SSEC}\n${ESEC}\n${PARTUID}\n</span>\n<span\tcolor='#ff0000'>dangerous</span>\n88"
              else 
                IRES="$IRES false\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\n<span\tcolor='#ff0000'>dangerous</span>\n88"
              fi
            ;;
            ${PSYSTEM})
            if [ -z "$IRES" ];then
                IRES="true\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\n<span\tcolor='#558000'>system-partition</span>\n2"
            else
                IRES="$IRES true\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\n<span\tcolor='#558000'>system-partition</span>\n2"
            fi
            ;;
            *)
            if [ -z "$IRES" ];then
                IRES="true\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\nunknown-type\n2"
            else
                IRES="$IRES true\n${PNAME}\n${PARTN}\n${SSEC}\n${ESEC}\n${PARTUID}\nunknown-type\n2"
            fi
            ;;
        esac
    done

    F_LOG "($FUNCNAME) created yad list: $IRES"
    echo "$IRES"
}; export -f F_GETPARTS

# factory reset a device
F_FACRESET(){ F_LOG "$FUNCNAME: started"
    # takes 1 (optional) argument
    # when no arg given we assume interactive mode
    #
    # 1 => interactive (ia) or not (ni)

    if [ -z $1 ];then WMODE=ia; else WMODE=$1; fi

    # clean userdata
    F_WIPEPART userdata $WMODE || F_MSGE 400 "Wiping userdata ended with an error: $WIPERR\n\nCheck debug Log in SALT advanced menu."
    # wipe cache
    F_WIPEPART cache $WMODE || F_MSGE 400 "Wiping cache ended with an error: $WIPERR\n\nCheck debug Log in SALT advanced menu."
}

# erase partitions
F_DELPART(){ F_LOG "$FUNCNAME: started"
    # takes no args
    
    IRES=$(F_GETPARTS)
    CHOOSENP=$((for files in $IRES;do echo -e "$files" | sed 's/true/false/g' ;done | $FYAD --height=800 --width=1000 --title="$YTITLE - WIPE" --text "\n  Select partition(s) to WIPE:\n" --list  --checklist\
            --column="Selection":CHK \
            --column="Partition":TXT \
            --column="#" \
            --column="Start sector" \
            --column="End sector" \
            --column="UID" \
            --column="Type" \
            --column="sort_int" \
            --listen --no-selection \
            --hide-column=8 \
            --button=WIPE:0 \
            --button=Abort:3) | cut -d "|" -f 2,3,8 | tr "|" ":")
    CERR=${PIPESTATUS[0]}
    F_LOG "CHOOSENP: $CHOOSENP"

    F_LOG "CERR: $CERR"
    [ $CERR -ne 0 ] && F_MSGE 400 "Aborted by user!" && F_EXIT $FUNCNAME $CERR

    CHCOUNT=$(echo "$CHOOSENP" |tr " " "\n" |grep -c :)
    [ $CHCOUNT -lt 1 ] && F_MSGE 400 "No partition selected?" && F_EXIT $FUNCNAME $CHCOUNT

    F_ELOG "choosen partitions: $CHOOSENP -> $CHCOUNT"

    SORTEDP=$(echo "$CHOOSENP" |tr " " "\n" | sort -t : -k 3n | cut -d ":" -f 1-2 | tr "\n" " ")
    SORTEDPH=$(echo "$SORTEDP" | tr " " "\n" |cut -d ":" -f1 )
    CHCOUNT=$(echo "$SORTEDP" |tr " " "\n" |grep -c :)

    LCERR=$(F_MSGW 600 "Last chance to stop!\n\n<b><span color='#ff0000'>THIS CAN EASILY HARD BRICK YOUR DEVICE IF YOU DO NOT KNOW WHAT YOU'RE DOING!</span></b>\n\nThese partitions will be erased when continuing:\n\n$SORTEDPH\n\nAre you totally sure?" "--button=WIPE-THEM:99")
    [ $LCERR -ne 99 ] && F_MSGE 400 "Aborted on user request!" && F_EXIT $FUNCNAME 4
    
    F_ELOG "sorted partitions: $SORTEDP -> $CHCOUNT"
    for w in $SORTEDP; do
        echo 0
        echo "#${w/:*}"
        sleep 2
        echo 40
        ($PYTHONBIN $LAFPATH/partitions.py ${CROPT} --wipe ${w/:*} 2>&1) >> $LOG
        if [ $? -ne 0 ];then
            echo "#ERROR: while wiping ${w/:*}"
            F_MSGE 600 "ERROR while wiping ${w/:*} !! " && F_EXIT $FUNCNAME 4
        else
            echo "#wiped ${w/:*} successfully"
            echo 100
        fi
    done | $FYAD --title="$YTITLE - ERASING" --text="\n  <b>SALT is now erasing selected partitions...</b>\n  (if the progress bar does NOT get up to 100%: DO NOT REBOOT THE DEVICE!)\n\n" --width 900 --progress --button='Abort':1 --button="Finish (wait until all is done)":0
    EERR=${PIPESTATUS[0]}
    if [ $EERR -eq 0 ];then
        F_MSGOK 400 "All partitions wiped successfully:\n\n$SORTEDPH"
    else
        F_MSGE 600 "  Problems occured while wiping (EERR: $EERR) or ABORTED by user!\n  Check log and do not poweroff the device until you fixed this!"
    fi
}; export -f F_DELPART

# flashing action for UsU
F_USUFLASH(){ F_LOG "$FUNCNAME: started with this args: $@"
    # takes 1 arg
    #
    # 1 => type of flashing
    USUDIRECT=undef

    # kill parent window
    kill -s SIGUSR1 $YAD_PID >> $LOG 2>&1

    FLTYPE=$1
    case $FLTYPE in
        sdcard) F_LOG "$FUNCNAME: Will load UsU from the external SD card.."
            USUSRC=/storage/external_SD/aboot_UsU.img
            DLMSRC=/storage/external_SD/laf_UsU.img
            RRSRC=/storage/external_SD/rawres_UsU.img
            $FYAD --width=800 --title="$YTITLE - UsU from sdcard" \
                --text="\n   Please do the following (without leaving download mode!):\n\n\t- take out the sdcard <b>now</b>\n\t- insert it in again\n\t- wait 5 sec\n\t- press 'Next'" \
                --button="Next":0 \
                --button=Abort:99
            [ $? -ne 0 ] && F_EXIT $FUNCNAME $?
        ;;
        internal) F_LOG "$FUNCNAME: Will load UsU from the internal storage.."
            USUSRC=/data/media/0/Download/aboot_UsU.img
            DLMSRC=/data/media/0/Download/laf_UsU.img
            RRSRC=/data/media/0/Download/rawres_UsU.img
            $PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  umount /data\0' --debug --rawshell 2>&1 >> $LOG
            $PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  mount -t ext4 /dev/block/bootdevice/by-name/userdata /data\0' --debug --rawshell 2>&1 >> $LOG
            F_LOG "$FUNCNAME: userdata mounting finished"
        ;;
        direct) F_LOG "$FUNCNAME: Will flash UsU directly to the device..."
            USUWHERE=$($FYAD --image="$SICONS/salt_logo_64x64.png" --width=600 --title="$YTITLE - UsU" --text="\n    To minimize the risk of taken down by LG:\n    SALT does <b>not</b> come bundled with the UsU unlock files.\n\n    You have to download them manually and tell me the location:\n     1. <b><span color='#ff0000'> aboot </span></b>UsU file\n" \
                        --form --field='    UsU unlock file (aboot UsU)':FL --file-filter='aboot UsU file | aboot_UsU.img' \
                        --button=Next:0)
            LASTDIR=$(echo $USUWHERE |cut -d "|" -f1 | sed 's#/aboot_UsU.img##g')
            DLMWHERE=$($FYAD --image="$SICONS/salt_logo_64x64.png" --width=600 --title="$YTITLE - UsU" --text="\n    2. <b><span color='#ff0000'> laf </span></b>UsU file\n" \
                        --form --field='    UsU download mode file (laf UsU)':FL --file-filter='laf UsU file | laf_UsU.img' "${LASTDIR}/laf_UsU.img"\
                        --button=Next:0)
            LASTDIR=$(echo $DLMWHERE |cut -d "|" -f1 | sed 's#/laf_UsU.img##g')
            RRWHERE=$($FYAD  --image="$SICONS/salt_logo_64x64.png" --width=600 --title="$YTITLE - UsU" --text="\n    3. <b><span color='#ff0000'> rawres </span></b>UsU file\n" \
                        --form --field='    UsU misc. file (rawres UsU)':FL --file-filter='rawres UsU file | rawres_UsU.img' "${LASTDIR}/rawres_UsU.img"\
                        --button=Next:0)
            USUDIRECT=$(echo $USUWHERE |cut -d "|" -f1)
            USUSRC="$USUDIRECT"
            DLMDIRECT=$(echo $DLMWHERE |cut -d "|" -f1)
            DLMSRC="$DLMDIRECT"
            RRDIRECT=$(echo $RRWHERE |cut -d "|" -f1)
            RRSRC="$RRDIRECT"
        ;;
        *) F_ELOG "$FUNCNAME: no valid FLTYPE choosen!!!"
           F_EXIT $FUNCNAME 2
        ;;
    esac

    # verify UsU file existence
    $FYAD --image="$SICONS/salt_logo_64x64.png" --title="$YTITLE - VERIFY" --text="\n  SALT is searching for the UsU files ...\n" --width=500 --progress --progress-text="searching ..." --pulsate --no-buttons --auto-close &
    PROGY=$! 
    if [ "$FLTYPE" == "direct" ];then
        if [ !  -f "$USUDIRECT" ] || [ !  -f "$DLMDIRECT" ] || [ !  -f "$RRDIRECT" ];then
            F_MSGE 700 "   Oops?!\n\n   You have choosen\n\n   $USUDIRECT (aboot)\n   $DLMDIRECT (laf)\n   $RRDIRECT (rawres)\n\n   but I can not find it...!\n\n   Try another method or ensure you stored it to the correct path."
            kill $PROGY
            F_EXIT $FUNCNAME 3
        else
            F_LOG "USUDIRECT: $USUDIRECT , DLMDIRECT: $DLMDIRECT, RRDIRECT: $RRDIRECT"
            kill $PROGY
        fi
    else
        USUEX=$($PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  ls '$USUSRC'\0' --rawshell)
        DLMEX=$($PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  ls '$DLMSRC'\0' --rawshell)
        RREX=$($PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  ls '$RRSRC'\0' --rawshell)
        F_LOG "$FUNCNAME: USUEX=$USUEX, DLMEX=$DLMEX, RREX=$RREX"
        kill $PROGY
        if [ -z "$USUEX" ]||[ -z "$DLMEX"]||[ -z "$RREX"];then 
            F_MSGE 700 "   Oops?!\n\n   You have choosen\n\n   $USUSRC\n   $DLMSRC\n   $RRSRC\n\n   but I can not find it...!\n\n   Try another method or ensure you stored it to the correct path."
            ($PYTHONBIN $LAFPATH/lglaf.py ${CROPT} -c '!EXEC  ls /storage/external_SD/*.img /data/media/0/Download/*.img\0' --rawshell 2>&1) >> $LOG 
            F_EXIT $FUNCNAME 5
        fi
    fi
    
    # give feedback to the impatient users
    FLPBAR=/tmp/flbbar
    echo 10> $FLPBAR
    tail -f $FLPBAR | $FYAD --image="$SICONS/salt_logo_64x64.png" --title="$YTITLE - FLASHING" --text="\n  Fasten your seat belt!\n  SALT is flashing UsU ...\n" --width=500 --progress --progress-text="activating UsU ..." --no-buttons --auto-close &
    PROGY=$!
    
    # verify writing in general (before actually writing to REAL aboot!!)
    F_DUMPPART abootbak "/tmp/UsU/before"
    TESTPRE=$(sha256sum /tmp/UsU/before/abootbak | cut -d " " -f1)
    F_LOG "$FUNCNAME: abootbak before flashing: $TESTPRE"
    echo "#pre-checking ..." >> $FLPBAR
    if [ "$FLTYPE" == "direct" ];then
        $PYTHONBIN $LAFPATH/partitions.py ${CROPT} --restore "$USUDIRECT" abootbak --batch 1>> $FLPBAR 2>> $LOG
    else
        F_LOG '!EXEC  dd if='$USUSRC' of=/dev/block/mmcblk0 seek=248832 bs=512\0'
        $PYTHONBIN $LAFPATH/lglaf.py ${CROPT} --debug -c '!EXEC  dd if='$USUSRC' of=/dev/block/mmcblk0 seek=248832 bs=512\0' --rawshell 2>&1 >> $LOG
    fi
    echo "#verifying pre-check ..." >> $FLPBAR
    F_DUMPPART abootbak "/tmp/UsU/after"
    TESTAFTER=$(sha256sum /tmp/UsU/after/abootbak | cut -d " " -f1)
    # verify test result
    F_LOG "$FUNCNAME: abootbak after flashing: $TESTAFTER"
    if [ "$TESTAFTER" == "$USUHASH" ];then
        F_LOG "$FUNCNAME: PERFECT! We can really write on this device!"
    else
        if [ "$TESTAFTER" == "$TESTPRE" ];then
            kill $PROGY
            F_LOG "$FUNCNAME: Expected HASH: $USUHASH but got $TESTAFTER"
            F_MSGE 800 "   PRE-TEST failure!\n\n   Sorry but flashing seems to be blocked on your device.\n   Nothing has changed! Pls use the <b>QFIL</b> method instead."
            F_EXIT $FUNCNAME 2
        else
            kill $PROGY
            F_LOG "$FUNCNAME: Expected HASH: $USUHASH but got $TESTAFTER"
            F_MSGE 500 "   PRE-TEST failure!\n\n   This should never happen but if you see this\n   a VERY critical error happened!\n\n   DO NOT POWER OFF YOUR DEVICE!\n\n   Instead use LGup to flash a KDZ otherwise you may hard brick!"
            F_EXIT $FUNCNAME 2
        fi
    fi

    # real flash
    echo 0 >> $FLPBAR
    echo "#preparing flashing! ..." >> $FLPBAR
    F_DUMPPART aboot "/tmp/UsU/before"
    F_DUMPPART laf "/tmp/UsU/before"
    F_DUMPPART raw_resources "/tmp/UsU/before"
    ABPRE=$(sha256sum /tmp/UsU/before/aboot|cut -d " " -f1)
    DLMPRE=$(sha256sum /tmp/UsU/before/laf|cut -d " " -f1)
    RRPRE=$(sha256sum /tmp/UsU/before/raw_resources|cut -d " " -f1)
    F_LOG "$FUNCNAME: aboot before flashing:\n$ABPRE\nlaf before: $DLMPRE\nrr before: $RRPRE"
    if [ "$FLTYPE" == "direct" ];then
        F_LOG 'flashing aboot and laf directly...'
        echo "#flashing UsU unlock ..." >> $FLPBAR
        $PYTHONBIN $LAFPATH/partitions.py ${CROPT} --debug --restore "$USUDIRECT" aboot --batch 1>> $FLPBAR 2>> $LOG
        echo "#flashing UsU laf ..." >> $FLPBAR
        F_LOG "flashing laf from $DLMDIRECT ..."
        $PYTHONBIN $LAFPATH/partitions.py ${CROPT} --debug --restore "$DLMDIRECT" laf --batch 1>> $FLPBAR 2>> $LOG

        echo "#flashing UsU rawres ..." >> $FLPBAR
        F_LOG "flashing rawres from $RRDIRECT ..."
        $PYTHONBIN $LAFPATH/partitions.py ${CROPT} --debug --restore "$RRDIRECT" raw_resources --batch 1>> $FLPBAR 2>> $LOG
    else
        # we have no progress indicator when flashing from the device storage so we need to pulsate..
        kill $PROGY
        tail -f $FLPBAR | $FYAD --image="$SICONS/salt_logo_64x64.png" --title="$YTITLE - FLASHING" --text="\n  Fasten your seat belt!\n  SALT is flashing UsU ...\n" --width=500 --progress --progress-text="starting ..." --pulsate --no-buttons --auto-close &
        PROGY=$!
        F_LOG "flashing aboot from $USUSRC..."
        echo "#flashing UsU unlock ..." >> $FLPBAR
        $PYTHONBIN $LAFPATH/lglaf.py ${CROPT} --debug -c '!EXEC  dd if='$USUSRC' of=/dev/block/mmcblk0 seek=237568 bs=512\0' --rawshell 2>&1 >> $LOG
        echo "#flashing UsU laf ..." >> $FLPBAR
        F_LOG "flashing laf from $DLMSRC ..."
        $PYTHONBIN $LAFPATH/lglaf.py ${CROPT} --debug -c '!EXEC  dd if='$DLMSRC' of=/dev/block/mmcblk0 seek=393216 bs=512\0' --rawshell 2>&1 >> $LOG

        RRSEEKSTART=$($PYTHONBIN $LAFPATH/partitions.py ${CROPT} --list --batch |grep "raw_resources:" |cut -d ":" -f 3)
        F_LOG "FUNCNAME: raw resources from partition listing:"
        $PYTHONBIN $LAFPATH/partitions.py ${CROPT} --list --batch |grep "raw_resources:" >> $LOG 2>&1
        # G4 must have rr between sector 770000 and 870000
        if [ "$RRSEEKSTART" -lt 770000 ] || [ "$RRSEEKSTART" -gt 870000 ];then
            F_MSGW 700 "Can not identify a valid seek start for rawres! SKIPPED!\nYou have to flash the rawres_UsU.img in fastboot to fully enable UsU"
        else
            echo "#flashing UsU rawres ..." >> $FLPBAR
            F_LOG "flashing rawres from $RRSRC with seekstart: $RRSEEKSTART ..."
            $PYTHONBIN $LAFPATH/lglaf.py ${CROPT} --debug -c '!EXEC  dd if='$RRSRC' of=/dev/block/mmcblk0 seek='$RRSEEKSTART' bs=512\0' --rawshell 2>&1 >> $LOG
        fi
    fi
    # verify real flashing
    echo "#verifying UsU unlock ..." >> $FLPBAR
    F_DUMPPART aboot "/tmp/UsU/after"
    F_DUMPPART laf "/tmp/UsU/after"
    F_DUMPPART raw_resources "/tmp/UsU/after"
    ABAFTER=$(sha256sum /tmp/UsU/after/aboot|cut -d " " -f1)
    LAFAFTER=$(sha256sum /tmp/UsU/after/laf|cut -d " " -f1)
    RRAFTER=$(sha256sum /tmp/UsU/after/raw_resources|cut -d " " -f1)
    F_LOG "$FUNCNAME: after flashing:\naboot = $ABAFTER\nlaf = $LAFAFTER\nrr = $RRAFTER"

    source "$HASHES"
    if [ $? -ne 0 ];then
        F_LOG "ERROR: including $HASHES"
        F_MSGE 700 "Cannot include UsU hash table!\nABORTED!"
        kill $PROGY
        F_EXIT $FUNCNAME 4
    fi
    F_LOG "UsU hashes included successfully!\nLAF: $DLMHASH\nrr: $RRHASH"
    
    # verify the whole result
    kill $PROGY
    if [ "$ABAFTER" == "$USUHASH" ];then
        if [ "$DLMHASH" != "$LAFAFTER" ]||[ "$RRHASH" != "$RRAFTER" ];then
            F_MSGW 700 "Some parts of UsU couldn't be flashed!\n\nLAF:\n$DLMHASH (wanted)\n$DLMPRE (before)\n$LAFAFTER (after)\n\nrawres:\n$RRHASH (wanted)\n$RRPRE (before)\n$RRAFTER (after)"
            $FYAD --width=700 --fixed --image="$SICONS/salt_logo_64x64.png" --title="$YTITLE - FB WAY" \
                --text "SALT will reboot your device now but it needs\n\n<b>YOU</b>\n\nto boot properly:\n\n<b>Before</b> pressing Continue:\n\npress the <b>Volume DOWN</b> button NOW\nand <b>keep</b> it pressed!!\n\nWhen you click continue wait until you see the fastboot mode\n(a black screen and a couple of lines).\nThen you can release that button." \
                --button=Continue:99
            if [ $? -eq 99 ];then
                F_LOG "REBOOT INITIATED by USER!" && $PYTHONBIN ${LAFPATH}/lglaf.py ${CROPT} -c '!CTRL RSET'
                F_USUFLFB laf "${DLMSRC%/*}" "${DLMSRC##*/}"
                F_USUFLFB raw_resources "${RRSRC%/*}" "${RRSRC##*/}"
                $FYAD --title="$YTITLE - FB FLASH" --width=700 --fixed --image="$SICONS/salt_logo_64x64.png" --text "Good! Now press\n\n <b>Volume UP (!!)</b> button\n\nand <b>keep</b> it pressed until you see the download mode.\nThen press Continue." --button=Continue
                $FBBIN reboot
                # check device connection
                F_CHKDEVCON
            else
                F_MSGE 600 "Aborted by user"
            fi
        fi
        F_MSGOK 800 "   <b>CONGRATULATIONS!</b>\n\n   You're now secureboot off / unlocked!\n\n   Have fun and enjoy your unleashed phone :) !\n\n   <b>Whats next?</b>\n\n   Follow the guide at <a href='https://bit.do/unlockG4'>https://bit.do/unlockG4</a>\n\n   Basic steps are:\n\t- flash TWRP in fastboot\n\t- flash UsU baseband twrp package in TWRP\n\t- flash your custom ROM\n\n   <b><span color='#ff0000'>If you skip flashing the UsU baseband twrp package you will very likely bootloop!</span></b>" '--show-uri'
        $FYAD --title="$YTITLE - Log upload" --width=700 --text "\n\n   Please upload your SALT logfile <b>NOW</b> to ensure important information will not get lost!\n   Click this button and then Upload:\n" \
            --form \
            --field="Upload SALT debug log!$SICONS/log_16x16.png":FBTN "$SALTPATH/getlog" \
            --button=Close
    else
        if [ "$ABAFTER" == "$ABPRE" ];then
            F_LOG "$FUNCNAME: Expected HASH: $USUHASH but got $ABAFTER"
            F_MSGE 800 "   Sorry but flashing seems to be blocked on your device.\n   Nothing has changed! Pls use the one of the other flashing methods."
            F_EXIT $FUNCNAME 2
        else
            F_LOG "$FUNCNAME: Expected HASH: $USUHASH but got $ABAFTER"
            F_MSGE 500 "   This should never happen but if you see this\n   a VERY critical error happened!\n\n   DO NOT POWER OFF YOUR DEVICE!\n\n   Instead use LGup to flash a KDZ otherwise you may hard brick!"
            F_EXIT $FUNCNAME 2
        fi
    fi

}; export -f F_USUFLASH

# flashing UsU extra parts by fastboot (requires UsU already flashed)
F_USUFLFB(){ F_LOG "$FUNCNAME: started with this args: $@"
    # takes 3 args
    #
    # required:
    # 1 => partition to flash
    # 2 => full path to file (without filename)
    # 3 => filename (without path)

    FBP=$1
    FBD="$2"
    FBFN="$3"
    FBF="${FBD}/${FBFN}"

    F_LOG "$FUNCNAME: missing argument:\nFBP=$FBP, FBD=$FBD, FBFN=$FBFN\nFBF=$FBF"
    [ -z "$FBP" -o -z "$FBD" -o -z "$FBFN" ] && F_MSGE 700 "Missing argument" && F_EXIT $FUNCNAME 3
 
    while [ ! -f "$FBF" ];do
        F_LOG "$FUNCNAME: no FBF given >$FBF<"
        FBFA=$($FYAD --image="$SICONS/salt_logo_64x64.png" --width=600 --fixed --title="$YTITLE - FB FLASH" --text="\n    Please tell me the location of the <b><span color='#ff0000'> $FBP </span></b>UsU file\n" \
                     --form --field='    UsU file':FL --file-filter="UsU file ($FBFN)| $FBFN" \
                     --button=Next:0 --button=Abort:99)
        [ "$?" -eq 99 ] && F_EXIT $FUNCNAME 4
        FBF=$(echo "$FBFA" | cut -d "|" -f 1)
    done

    F_LOG "$FUNCNAME: Will flash $FBF to $FBP"
    $FBBIN flash $FBP "$FBF" 2>&1| sed 's/^/#/g'| tee -a $LOG | $FYAD --width=600 --image="$SICONS/salt_logo_64x64.png" --title="$YTITLE - FB FLASH" --text "\nFlashing $FBP..." --progress --progress-text="...waiting" --pulsate --autoclose --autokill
}; export -f F_USUFLFB

# check LAF protocol version
F_CHKLAFV(){ F_LOG "$FUNCNAME: started with this args: $@"
    # takes 1 arg
    # returns:
    #   no args: detected version | unknown (detect failed)
    #   w arg: 0(ok) | 1(not ok) | unknown (detect failed)
    #
    # optional: 
    # 1 => compare the detection with a max allowed version

    MAXV="$1"
    LAFV=$($PYTHONBIN $LAFPATH/lglaf.py ${CROPT} --proto --rawshell)
    if [ $? -ne 0 ]||[ -z "$LAFV" ]||[ "$LAFV" -lt 1000001 -o "$LAFV" -gt 2000000 ];then
        F_LOG "$FUNCNAME: Unexpected error while retrieving LAF protocol version ($LAFV)"
        echo "unknown"
    else
        F_LOG "$FUNCNAME: detected $LAFV"
        if [ -z "$MAXV" ];then
            F_LOG "$FUNCNAME: no comparison needed"
            echo "$LAFV"
        else
            if [ "$LAFV" -le "$MAXV" ];then
                F_LOG "$FUNCNAME: $LAFV is expected range ($MAXV)"
                echo 0
            else
                F_LOG "$FUNCNAME: $LAFV is higher then expected ($MAXV)"
                echo 1
            fi
        fi
    fi
}; export -f F_CHKLAFV

# Unofficial steadfasterX Unlock
F_DOUSU(){ F_LOG "$FUNCNAME: started with this args: $@"
    # Takes 1 argument
    #
    # 1 => model name

    # kill parent window
    kill -s SIGUSR1 $YAD_PID >> $LOG 2>&1

    # check device connection
    F_CHKDEVCON

    # UsU flashing in SALT will work only up to (including) LAF v4
    RE=$(F_CHKLAFV 1000004)
    if [ "$RE" == "0" ];then
        F_LOG "$FUNCNAME: This laf version is supported!"
    else
        F_MSGE 600 "Oops!\n\nYour Download mode version is not supported!\n\nDowngrade to LP or MM!"
        F_EXIT $FUNCNAME 4
    fi

    # UsU may NOT work with ARB > 2
    ARB=$(F_CDARB)
    DEVARBVAL=$(echo ${ARB}| cut -d ":" -f 1)
    DEVARBEMPT=$(echo ${ARB}| cut -d ":" -f 2)

    if [ $DEVARBEMPT -eq 0 ];then
        DEVARB=$DEVARBVAL
    else
        DEVARB="ARB_unknown"
        F_MSGE 700 "I cannot determine your ARB!\n\nUsU can be flashed only on ARB up to including 2!\n\nABORTED to avoid damage."
        F_EXIT no-arb 3
    fi
    if [ "$DEVARB" -le 2 ];then
        F_LOG "GOOD! Your ARB ($DEVARB) is compatible."
    else
        F_MSGE 700 "UsU can be flashed only on ARB up to including <b>2</b> !\n\nYour ARB is: <b>$DEVARB</b>\n\nABORTED to avoid damage."
        F_EXIT arb-not-allowed 3
    fi

    UMOD=$1
    export LGMODEL=$UMOD
    USUVALIDS="@(LG-G4_UsU|*LS991*|*F500*|*H810*|*H812*|*H811*|*H815*|*H819*|*US991*|*VS986*)"

    shopt -s extglob

    case $UMOD in
        ${USUVALIDS}) F_LOG "$FUNCNAME: Valid UsU model found ($UMOD)"
        ;;
        *) F_ELOG "$FUNCNAME: device model $UMOD is not working with this method!"
           F_MSGE 900 "  Your device <b>$UMOD</b> is not supported by this method!\n\n  Supported are:\n\n  $USUVALIDS"
           F_EXIT $FUNCNAME 4
        ;;
    esac
    
    A=$(F_MSGW 900 "  Your device ($UMOD) is supported by UsU!\n\n  This unlock works for any <b>G4</b> model out there but for <b>no other device!</b>\n\n  <b><span color='#ff0000'>Unlocking your device is a risk - always!</span></b>\n\n  You do this on your <b>own</b> risk and without any guarantees\n\n  I do my best to avoid damage but don't cry when this here fails for you.\n  Ensure you have taken at least a basic backup with SALT before proceeding!\n  That backup is your only chance for recovery!" "--button=UNLOCK:99 --fixed")

    F_LOG "$FUNCNAME: Answered: $A"
    if [ "$A" == "99" ];then
        if [ "$LAFVER" == "100001" ];then
          USUF=$($FYAD --width=800 --title="$YTITLE - UsU" --text="\n   UsU can be installed from either the internal storage or from an external SD card.\n   The paths for the UsU file are FIX and <b>can not</b> be changed:\n" \
            --form --columns=2\
            --field='   Placed <b>directly</b> on the sdcard - no subfolder!':LBL true \
            --field='   Placed in <b>/data/media/0/Download</b>':LBL true \
            --field="UNLOCK by external SDcard":FBTN "bash -c 'F_USUFLASH sdcard'"\
            --field="UNLOCK by /data/media/0/Download":FBTN "bash -c 'F_USUFLASH internal'"\
            --button="Cancel":0)
        else
           USUF=$($FYAD --width=800 --title="$YTITLE - UsU" --text="\n   UsU can be installed from either the internal storage or from an external SD card.\n   The paths for the UsU file are FIX and <b>can not
</b> be changed:\n" \
            --form --columns=2\
            --field='   Placed <b>directly</b> on the sdcard - no subfolder!':LBL true \
            --field='   Placed in <b>/data/media/0/Download</b>':LBL true \
            --field='   Transfer UsU directly from your <b>PC</b>':LBL true \
            --field="UNLOCK by external SDcard":FBTN "bash -c 'F_USUFLASH sdcard'"\
            --field="UNLOCK by /data/media/0/Download":FBTN "bash -c 'F_USUFLASH internal'"\
            --field="UNLOCK by direct flash":FBTN "bash -c 'F_USUFLASH direct'"\
            --button="Close":0)
        fi

        if [ $? -eq 98 ];then
            USUFL="${USUF/\|/}"
            F_LOG "$FUNCNAME: UsU file selected: $USUFL"
            # check device connection
            F_CHKDEVCON            
        else
            F_LOG "$FUNCNAME: aborted by user"
        fi
    fi

}; export -f F_DOUSU

# new version check
F_VCHK(){ F_LOG "$FUNCNAME: started with this args: $@"
    # Takes no argument
    #
    ONLVF=$($CURLB --connect-timeout 10 --stderr $LOG -s $VCHK | grep "VDIG=" | cut -d "=" -f 2 | tr -d '"')
    ONLV=$(echo "$ONLVF" | tr -d "." | cut -d "-" -f1)
    CURVF=$(echo "$VDIG" | cut -d "=" -f 2 | tr -d '"')
    CURV=$(echo "$CURVF" | tr -d "." | cut -d "-" -f1)

    if [ -z "$ONLV" ]||[ -z "$CURV" ];then
      F_LOG "$FUNCNAME: cannot check for new version:\nonline: $ONLV / $ONLVF\nhere: $CURV / $CURVF"
    else
      if [ $ONLV -gt $CURV ];then
        F_LOG "$FUNCNAME: newer SALT version found ($ONLV / $ONLVF vs. $CURV / $CURVF)"
        UA=$(F_MSGW 700 "New SALT version available!\n\nYou:\t<b>$CURVF</b>\nOnline:\t<b>$ONLVF</b>\n\nDo you want to update now?" "--button=Update:99")
        if [ "$UA" == 99 ];then
            (F_UPDATE)
            F_MSGOK 600 "Will close SALT now due to the update taken!\nJust re-open SALT afterwards."
            F_EXIT "After-Update-End" 0 full 
        fi
      else
        F_LOG "$FUNCNAME: no newer SALT version found ($ONLV / $ONLVF vs. $CURV / $CURVF)"
      fi
    fi
}; export -f F_VCHK

## @fn F_CHKFREE()
## @brief check free disk space for a given folder
## @param 1 the folder / mountpoint to check
## @return free amount of disk space in MB
## @exception when param1 does not exists or can not be opened
F_CHKFREE(){ F_LOG "$FUNCNAME: started with this args: $@"
    CKDIR="$1"
    
    if [ -d "$CKDIR" ];then
        F_LOG "$FUNCNAME: valid dir specificed"
        $DFBIN -m "$CKDIR" | $AWKBIN '{print $4}' | $EGREPBIN "[[:digit:]]"
    else
        F_LOG "$FUNCNAME: The specified directory $CKDIR does not exists"
        echo 0
    fi
    F_LOG "$FUNCNAME: ended."
}; export -f F_CHKFREE

## @fn F_CRRESTART()
## @brief change the CR mode in fix order!
## @param 1 The main SALT window pid (required for killing it)
## @param 2 The mode you currently have: Auto|yes|no
## @exception when param1 does not exists
F_CRRESTART(){ F_LOG "$FUNCNAME: started with this args: $@"
    MAIN_YAD_PID=$1
    CURRENTCR="$2"
    F_LOG "$FUNCNAME: YAD_PID is $MAIN_YAD_PID"
 
    [ -z "$CURRENTCR" -o -z "$MAIN_YAD_PID" ] && F_EXIT "$FUNCNAME: missing parameter CURRENTCR or MAIN_YAD_PID" 0

    case $CURRENTCR in
        Auto)export CRMODE=yes;;
        yes)export CRMODE=no;;
        no)export CRMODE=Auto;;
    esac

    F_LOG "$FUNCNAME: Will change CR from $CURRENTCR to $CRMODE"
    # kill parent windows
    kill -s SIGUSR1 $YAD_PID >> $LOG 2>&1
    kill -s SIGUSR1 $MAIN_YAD_PID >> $LOG 2>&1
    
    F_LOG "$FUNCNAME: Will restart SALT now like that: $FULLCMD"
    $FULLCMD
    F_LOG "$FUNCNAME: ended."
}; export -f F_CRRESTART



